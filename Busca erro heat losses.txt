 end else if Form_HeatLosses.RG_SystemType.ItemIndex = 3 then begin  /////////////////////////////////////////////////////////////////////////////////////////////////////////HCC


  Error_Loss := 0;
  Erro_Twall_1 := 1;
  while Error_Loss < 1 do begin
  Cont_Loss := 0;

  Cont_Loss_ini := Cont_Loss_ini+1;

   if Form_HeatLosses.RG_NoWalls.ItemIndex = 0 then begin   //Neste caso, temos CC em Norte de fluxo constante e em Sul de conveccao

    //saving old temperatures
    Length_dlss:= Delta_L_dlss/2;
    For Volume := 0 to MeshSize+1 do begin
      if Cont_Loss_ini = 0 then begin
        for volume_y := 0 to mesh_wall1+1 do begin
         T_wall_1old[Volume,volume_y] := T_wall1_TSBefore[volume,volume_y];
        end;
        for volume_y := 0 to mesh_air1+1 do begin
         T_air_1old[Volume,volume_y] := T_air1_TSBefore[volume,volume_y];
        end;
      end else begin
       for volume_y := 0 to mesh_wall1+1 do begin
         T_wall_1old[Volume,volume_y] := T_wall_1[volume,volume_y];
        end;
        for volume_y := 0 to mesh_air1+1 do begin
         T_air_1old[Volume,volume_y] := T_air_1[volume,volume_y];
        end;
      end;
    end;


    //Updating Solid and Fluid temperatures and properties
    For Volume := 0 to MeshSize+1 do begin

     T_fp[volume] := T_fOld[Cont_Int, volume];
     T_sp[volume] := T_sOld[Cont_Int, volume];

     //Working Fluid Properties
     rho_fp[Volume] := - 517.378
                      + 14.3157*(T_fp[volume]*T_spam + T_CHEX)
                      - 0.0440498*Power((T_fp[volume]*T_spam + T_CHEX),2)
                      + 0.0000438395*Power((T_fp[volume]*T_spam + T_CHEX),3);
     mu_fp[Volume] := 0.79913
                   - 0.00976317*(T_fp[volume]*T_spam + T_CHEX)
                   + 0.0000449597*Power((T_fp[volume]*T_spam + T_CHEX),2)
                   - 0.000000092347*Power((T_fp[volume]*T_spam + T_CHEX),3)
                   + 0.0000000000713175*Power((T_fp[volume]*T_spam + T_CHEX),4);
     k_fp[Volume] := - 0.680944
                    + 0.00687609*(T_fp[volume]*T_spam + T_CHEX)
                    - 0.00000871265*Power((T_fp[volume]*T_spam + T_CHEX),2);

     if (T_fp[volume]*T_spam + T_CHEX) < 293 then begin
     cp_fp[volume] := 245103
                     - 2503.25*(T_fp[volume]*T_spam + T_CHEX)
                     + 8.67151*Power((T_fp[volume]*T_spam + T_CHEX),2)
                     - 0.0100147*Power((T_fp[volume]*T_spam + T_CHEX),3);
     end else begin
     cp_fp[volume] := 4184;
     end;
     nu_fp[Volume] := mu_fp[Volume]/rho_fp[Volume];
     dif_fp[volume] := k_fp[Volume]/(rho_fp[Volume]*cp_fp[volume]);
     Pr_fp[Volume] := nu_fp[Volume]/dif_fp[volume];
     //End Fluid Properties

     //Properties correction for water glycol
      if Glycol_vol > 0 then begin
       rho_fp[Volume] := rho_fp[Volume]*
                       (1.089040385
                       - 0.01022673*(T_fp[volume]*T_spam + T_CHEX)
                       + 0.0000312579*Power((T_fp[volume]*T_spam + T_CHEX),2)
                       - 0.000000032614*Power((T_fp[volume]*T_spam + T_CHEX),3)
                       - 0.02518839*Glycol_wt
                       - 0.00060141*Power(Glycol_wt,2))/
                      (1
                       - 0.009426*(T_fp[volume]*T_spam + T_CHEX)
                       + 0.0000289266*Power((T_fp[volume]*T_spam + T_CHEX),2)
                       - 0.000000030449*Power((T_fp[volume]*T_spam + T_CHEX),3)
                       - 0.01825238*Glycol_wt);
       mu_fp[Volume] := mu_fp[Volume]*
                      (- 0.48083137
                       + 0.003165299*(T_fp[volume]*T_spam + T_CHEX)
                       - 0.0000055754*Power((T_fp[volume]*T_spam + T_CHEX),2)
                       - 0.04388738*Glycol_wt
                       - 0.0831036*Power(Glycol_wt,2))/
                      (1
                       - 0.01052098*(T_fp[volume]*T_spam + T_CHEX)
                       + 0.0000362597*Power((T_fp[volume]*T_spam + T_CHEX),2)
                       - 0.000000042298*Power((T_fp[volume]*T_spam + T_CHEX),3)
                       + 0.026624841*Glycol_wt);
       k_fp[Volume] := k_fp[Volume]*
                       (0.769354184
                       - 0.00648959*(T_fp[volume]*T_spam + T_CHEX)
                       - 0.0000040541*Power((T_fp[volume]*T_spam + T_CHEX),2)
                       - 2.86147298*Glycol_wt
                       + 0.060202185*Power(Glycol_wt,2)
                       + 0.010604554*(T_fp[volume]*T_spam + T_CHEX)*Glycol_wt)/
                      (1
                       - 0.00780393*(T_fp[volume]*T_spam + T_CHEX)
                       - 0.0000019933*Power((T_fp[volume]*T_spam + T_CHEX),2)
                       + 0.109891962*Glycol_wt
                       - 0.20530181*Power(Glycol_wt,2)
                       - 0.00296141*(T_fp[volume]*T_spam + T_CHEX)*Glycol_wt);
       cp_fp[volume] := cp_fp[volume]*
                        (15.60442824
                        - 13270.6349/(T_fp[volume]*T_spam + T_CHEX)
                        + 4017470/Power((T_fp[volume]*T_spam + T_CHEX),2)
                        - 405000000/Power((T_fp[volume]*T_spam + T_CHEX),3)
                        + 1.791510444*Glycol_wt
                        - 0.43299511*Power(Glycol_wt,2)
                        - 0.16418117*Power(Glycol_wt,3)
                        - 1061.16827*Glycol_wt/(T_fp[volume]*T_spam + T_CHEX)
                        + 125.020179*Power(Glycol_wt,2)/(T_fp[volume]*T_spam + T_CHEX)
                        + 130141.358*Glycol_wt/Power((T_fp[volume]*T_spam + T_CHEX),2));

       nu_fp[Volume] := mu_fp[Volume]/rho_fp[Volume];
       dif_fp[volume] := k_fp[Volume]/(rho_fp[Volume]*cp_fp[volume]);
       Pr_fp[Volume] := nu_fp[Volume]/dif_fp[volume];
      end;

    //End Fluid Properties

       //Solid Properties
       rho_sp[Volume] := 7900;                                                  //Solid Density
       k_sp[Volume] := 10.5;                                                    //Solid thermal condutivety


        for hh := 1 to malha_campo do begin
         if H_eff[Cont_time_cycle,volume] = MatrixField[hh] then begin
          Ponto_H := hh;
         end;
         if (H_eff[Cont_time_cycle,volume] > MatrixField[hh]) and (H_eff[Cont_time_cycle,volume] < MatrixField[hh+1]) then begin
          Ponto_H := hh;
         end;
        end;


       //1 Layer
       if Form_MagnetocaloricMaterial.RG_NumberofLayers.ItemIndex = 0 then begin
        for tt := 1 to malha_temperatura do begin
         if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L1[tt] then begin
          Ponto_T := tt;
         end;
         if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L1[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L1[tt+1])  then begin
          Ponto_T := tt;
         end;
        end;

       cp_sp[volume]  :=   CHtotal_L1[Ponto_T,Ponto_H]    *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                           CHtotal_L1[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                           CHtotal_L1[Ponto_T,Ponto_H+1]  *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                           CHtotal_L1[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));
       end;
       //end 1 layer

       //2 Layers
       if Form_MagnetocaloricMaterial.RG_NumberofLayers.ItemIndex = 1 then begin
        if ((Length_dlss - Delta_L_dlss/2) < L1_frac) and ((Length_dlss + Delta_L_dlss/2) < L1_frac) then begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L1[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L1[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L1[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

        cp_sp[volume]  :=   CHtotal_L1[Ponto_T,Ponto_H]    *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T,Ponto_H+1]  *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end else if ((Length_dlss - Delta_L_dlss/2) < L1_frac) and ((Length_dlss + Delta_L_dlss/2) > L1_frac) then begin
         Delta_L1 := L1_frac - (Length_dlss - Delta_L_dlss/2);
	       Delta_L2 := Delta_L_dlss - Delta_L1;

         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L1[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L1[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L1[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M1  :=   CHtotal_L1[Ponto_T,Ponto_H]    *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T,Ponto_H+1]  *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L2[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L2[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L2[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M2  :=   CHtotal_L2[Ponto_T,Ponto_H]    *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T,Ponto_H+1]  *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

         cp_sp[volume]  :=  (Delta_L1*cp_M1 + Delta_L2*cp_M2)/(Delta_L1+Delta_L2);

        end else begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L2[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L2[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L2[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

         cp_sp[volume]  :=   CHtotal_L2[Ponto_T,Ponto_H]    *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T,Ponto_H+1]  *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end;
       end;
       //end 2 layers
       //3 Layers
       if Form_MagnetocaloricMaterial.RG_NumberofLayers.ItemIndex = 2 then begin
        if ((Length_dlss - Delta_L_dlss/2) < L1_frac) and ((Length_dlss + Delta_L_dlss/2) < L1_frac) then begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L1[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L1[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L1[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

        cp_sp[volume]  :=   CHtotal_L1[Ponto_T,Ponto_H]    *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T,Ponto_H+1]  *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end else if ((Length_dlss - Delta_L_dlss/2) < L1_frac) and ((Length_dlss + Delta_L_dlss/2) > L1_frac) then begin
         Delta_L1 := L1_frac - (Length_dlss - Delta_L_dlss/2);
	       Delta_L2 := Delta_L_dlss - Delta_L1;

         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L1[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L1[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L1[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M1  :=   CHtotal_L1[Ponto_T,Ponto_H]    *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T,Ponto_H+1]  *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L2[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L2[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L2[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M2  :=   CHtotal_L2[Ponto_T,Ponto_H]    *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T,Ponto_H+1]  *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

         cp_sp[volume]  :=  (Delta_L1*cp_M1 + Delta_L2*cp_M2)/(Delta_L1+Delta_L2);

        end else if ((Length_dlss - Delta_L_dlss/2) < (L1_frac + L2_frac)) and ((Length_dlss + Delta_L_dlss/2) < (L1_frac + L2_frac)) then begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L2[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L2[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L2[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

         cp_sp[volume]  :=   CHtotal_L2[Ponto_T,Ponto_H]    *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T,Ponto_H+1]  *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end else if ((Length_dlss - Delta_L_dlss/2) < (L1_frac + L2_frac)) and ((Length_dlss + Delta_L_dlss/2) > (L1_frac + L2_frac)) then begin
            Delta_L1 := (L1_frac + L2_frac) - (Length_dlss - Delta_L_dlss/2);
	          Delta_L2 := Delta_L_dlss - Delta_L1;

         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L2[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L2[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L2[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M1  :=   CHtotal_L2[Ponto_T,Ponto_H]    *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T,Ponto_H+1]  *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L3[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L3[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L3[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M2  :=   CHtotal_L3[Ponto_T,Ponto_H]    *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T,Ponto_H+1]  *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

         cp_sp[volume]  :=  (Delta_L1*cp_M1 + Delta_L2*cp_M2)/(Delta_L1+Delta_L2);
         end else begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L3[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L3[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L3[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

         cp_sp[volume]  :=   CHtotal_L3[Ponto_T,Ponto_H]    *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T,Ponto_H+1]  *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end;

       end;
       //end 3 layers
       //4 Layers
       if Form_MagnetocaloricMaterial.RG_NumberofLayers.ItemIndex = 3 then begin
        if ((Length_dlss - Delta_L_dlss/2) < L1_frac) and ((Length_dlss + Delta_L_dlss/2) < L1_frac) then begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L1[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L1[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L1[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

        cp_sp[volume]  :=   CHtotal_L1[Ponto_T,Ponto_H]    *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T,Ponto_H+1]  *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end else if ((Length_dlss - Delta_L_dlss/2) < L1_frac) and ((Length_dlss + Delta_L_dlss/2) > L1_frac) then begin
         Delta_L1 := L1_frac - (Length_dlss - Delta_L_dlss/2);
	       Delta_L2 := Delta_L_dlss - Delta_L1;

         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L1[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L1[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L1[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M1  :=   CHtotal_L1[Ponto_T,Ponto_H]    *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T,Ponto_H+1]  *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L2[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L2[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L2[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M2  :=   CHtotal_L2[Ponto_T,Ponto_H]    *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T,Ponto_H+1]  *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

         cp_sp[volume]  :=  (Delta_L1*cp_M1 + Delta_L2*cp_M2)/(Delta_L1+Delta_L2);

        end else if ((Length_dlss - Delta_L_dlss/2) < (L1_frac + L2_frac)) and ((Length_dlss + Delta_L_dlss/2) < (L1_frac + L2_frac)) then begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L2[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L2[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L2[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

         cp_sp[volume]  :=   CHtotal_L2[Ponto_T,Ponto_H]    *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T,Ponto_H+1]  *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end else if ((Length_dlss - Delta_L_dlss/2) < (L1_frac + L2_frac)) and ((Length_dlss + Delta_L_dlss/2) > (L1_frac + L2_frac)) then begin
            Delta_L1 := (L1_frac + L2_frac) - (Length_dlss - Delta_L_dlss/2);
	          Delta_L2 := Delta_L_dlss - Delta_L1;

         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L2[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L2[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L2[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M1  :=   CHtotal_L2[Ponto_T,Ponto_H]    *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T,Ponto_H+1]  *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L3[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L3[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L3[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M2  :=   CHtotal_L3[Ponto_T,Ponto_H]    *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T,Ponto_H+1]  *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

         cp_sp[volume]  :=  (Delta_L1*cp_M1 + Delta_L2*cp_M2)/(Delta_L1+Delta_L2);
         end else if ((Length_dlss - Delta_L_dlss/2) < (L1_frac + L2_frac + L3_frac)) and ((Length_dlss + Delta_L_dlss/2) < (L1_frac + L2_frac + L3_frac)) then begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L3[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L3[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L3[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

         cp_sp[volume]  :=   CHtotal_L3[Ponto_T,Ponto_H]    *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T,Ponto_H+1]  *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end else if ((Length_dlss - Delta_L_dlss/2) < (L1_frac + L2_frac + L3_frac)) and ((Length_dlss + Delta_L_dlss/2) > (L1_frac + L2_frac + L3_frac)) then begin
            Delta_L1 := (L1_frac + L2_frac + L3_frac) - (Length_dlss - Delta_L_dlss/2);
	          Delta_L2 := Delta_L_dlss - Delta_L1;

         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L3[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L3[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L3[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M1  :=   CHtotal_L3[Ponto_T,Ponto_H]    *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T,Ponto_H+1]  *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L4[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L4[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L4[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M2  :=   CHtotal_L4[Ponto_T,Ponto_H]    *((MatrixTemp_L4[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L4[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L4[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L4[Ponto_T,Ponto_H+1]  *((MatrixTemp_L4[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L4[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L4[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

         cp_sp[volume]  :=  (Delta_L1*cp_M1 + Delta_L2*cp_M2)/(Delta_L1+Delta_L2);
         end else begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L4[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L4[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L4[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

         cp_sp[volume]  :=   CHtotal_L4[Ponto_T,Ponto_H]    *((MatrixTemp_L4[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L4[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L4[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L4[Ponto_T,Ponto_H+1]  *((MatrixTemp_L4[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L4[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L4[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end;

       end;
       //end 4 layers
       //5 Layers
       if Form_MagnetocaloricMaterial.RG_NumberofLayers.ItemIndex = 4 then begin
        if ((Length_dlss - Delta_L_dlss/2) < L1_frac) and ((Length_dlss + Delta_L_dlss/2) < L1_frac) then begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L1[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L1[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L1[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

        cp_sp[volume]  :=   CHtotal_L1[Ponto_T,Ponto_H]    *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T,Ponto_H+1]  *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end else if ((Length_dlss - Delta_L_dlss/2) < L1_frac) and ((Length_dlss + Delta_L_dlss/2) > L1_frac) then begin
         Delta_L1 := L1_frac - (Length_dlss - Delta_L_dlss/2);
	       Delta_L2 := Delta_L_dlss - Delta_L1;

         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L1[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L1[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L1[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M1  :=   CHtotal_L1[Ponto_T,Ponto_H]    *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T,Ponto_H+1]  *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L2[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L2[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L2[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M2  :=   CHtotal_L2[Ponto_T,Ponto_H]    *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T,Ponto_H+1]  *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

         cp_sp[volume]  :=  (Delta_L1*cp_M1 + Delta_L2*cp_M2)/(Delta_L1+Delta_L2);

        end else if ((Length_dlss - Delta_L_dlss/2) < (L1_frac + L2_frac)) and ((Length_dlss + Delta_L_dlss/2) < (L1_frac + L2_frac)) then begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L2[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L2[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L2[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

         cp_sp[volume]  :=   CHtotal_L2[Ponto_T,Ponto_H]    *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T,Ponto_H+1]  *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end else if ((Length_dlss - Delta_L_dlss/2) < (L1_frac + L2_frac)) and ((Length_dlss + Delta_L_dlss/2) > (L1_frac + L2_frac)) then begin
            Delta_L1 := (L1_frac + L2_frac) - (Length_dlss - Delta_L_dlss/2);
	          Delta_L2 := Delta_L_dlss - Delta_L1;

         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L2[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L2[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L2[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M1  :=   CHtotal_L2[Ponto_T,Ponto_H]    *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T,Ponto_H+1]  *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L3[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L3[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L3[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M2  :=   CHtotal_L3[Ponto_T,Ponto_H]    *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T,Ponto_H+1]  *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

         cp_sp[volume]  :=  (Delta_L1*cp_M1 + Delta_L2*cp_M2)/(Delta_L1+Delta_L2);
         end else if ((Length_dlss - Delta_L_dlss/2) < (L1_frac + L2_frac + L3_frac)) and ((Length_dlss + Delta_L_dlss/2) < (L1_frac + L2_frac + L3_frac)) then begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L3[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L3[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L3[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

         cp_sp[volume]  :=   CHtotal_L3[Ponto_T,Ponto_H]    *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T,Ponto_H+1]  *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end else if ((Length_dlss - Delta_L_dlss/2) < (L1_frac + L2_frac + L3_frac)) and ((Length_dlss + Delta_L_dlss/2) > (L1_frac + L2_frac + L3_frac)) then begin
            Delta_L1 := (L1_frac + L2_frac + L3_frac) - (Length_dlss - Delta_L_dlss/2);
	          Delta_L2 := Delta_L_dlss - Delta_L1;

         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L3[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L3[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L3[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M1  :=   CHtotal_L3[Ponto_T,Ponto_H]    *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T,Ponto_H+1]  *((MatrixTemp_L3[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L3[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L3[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L3[Ponto_T+1]-MatrixTemp_L3[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L4[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L4[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L4[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M2  :=   CHtotal_L4[Ponto_T,Ponto_H]    *((MatrixTemp_L4[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L4[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L4[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L4[Ponto_T,Ponto_H+1]  *((MatrixTemp_L4[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L4[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L4[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

         cp_sp[volume]  :=  (Delta_L1*cp_M1 + Delta_L2*cp_M2)/(Delta_L1+Delta_L2);
         end else if ((Length_dlss - Delta_L_dlss/2) < (L1_frac + L2_frac + L3_frac + L4_frac)) and ((Length_dlss + Delta_L_dlss/2) < (L1_frac + L2_frac + L3_frac + L4_frac)) then begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L4[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L4[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L4[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

         cp_sp[volume]  :=   CHtotal_L4[Ponto_T,Ponto_H]    *((MatrixTemp_L4[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L4[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L4[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L4[Ponto_T,Ponto_H+1]  *((MatrixTemp_L4[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L4[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L4[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end else if ((Length_dlss - Delta_L_dlss/2) < (L1_frac + L2_frac + L3_frac + L4_frac)) and ((Length_dlss + Delta_L_dlss/2) > (L1_frac + L2_frac + L3_frac + L4_frac)) then begin
            Delta_L1 := (L1_frac + L2_frac + L3_frac + L4_frac) - (Length_dlss - Delta_L_dlss/2);
	          Delta_L2 := Delta_L_dlss - Delta_L1;

         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L4[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L4[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L4[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M1  :=   CHtotal_L4[Ponto_T,Ponto_H]    *((MatrixTemp_L4[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L4[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L4[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L4[Ponto_T,Ponto_H+1]  *((MatrixTemp_L4[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L4[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L4[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L4[Ponto_T+1]-MatrixTemp_L4[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L5[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L5[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L5[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M2  :=   CHtotal_L5[Ponto_T,Ponto_H]    *((MatrixTemp_L5[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L5[Ponto_T+1]-MatrixTemp_L5[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L5[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L5[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L5[Ponto_T+1]-MatrixTemp_L5[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L5[Ponto_T,Ponto_H+1]  *((MatrixTemp_L5[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L5[Ponto_T+1]-MatrixTemp_L5[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L5[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L5[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L5[Ponto_T+1]-MatrixTemp_L5[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

         cp_sp[volume]  :=  (Delta_L1*cp_M1 + Delta_L2*cp_M2)/(Delta_L1+Delta_L2);
         end else begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L5[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L5[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L5[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

         cp_sp[volume]  :=   CHtotal_L5[Ponto_T,Ponto_H]    *((MatrixTemp_L5[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L5[Ponto_T+1]-MatrixTemp_L5[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L5[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L5[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L5[Ponto_T+1]-MatrixTemp_L5[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L5[Ponto_T,Ponto_H+1]  *((MatrixTemp_L5[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L5[Ponto_T+1]-MatrixTemp_L5[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L5[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L5[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L5[Ponto_T+1]-MatrixTemp_L5[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end;

       end;
       //end 5 layers

       { Old Program.

       for hh := 1 to malha_campo do begin
         if H_eff[Cont_time_cycle,volume] = MatrixField[hh] then begin
          Ponto_H := hh;
         end;
         if (H_eff[Cont_time_cycle,volume] > MatrixField[hh]) and (H_eff[Cont_time_cycle,volume] < MatrixField[hh+1]) then begin
          Ponto_H := hh;
         end;
        end;

        for tt := 1 to malha_temperatura do begin
         if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L1[tt] then begin
          Ponto_T := tt;
         end;
         if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L1[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L1[tt+1])  then begin
          Ponto_T := tt;
         end;
        end;

       cp_sp[volume]  :=   CHtotal_L1[Ponto_T,Ponto_H]    *((MatrixTemp[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp[Ponto_T+1]-MatrixTemp[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                           CHtotal_L1[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp[Ponto_T+1]-MatrixTemp[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                           CHtotal_L1[Ponto_T,Ponto_H+1]  *((MatrixTemp[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp[Ponto_T+1]-MatrixTemp[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                           CHtotal_L1[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp[Ponto_T+1]-MatrixTemp[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

          }


     //Effective thermal conduction
     if (RG_geometry.ItemIndex = 0) or (RG_geometry.ItemIndex = 3) then begin   //Parallel Plates and Microchannels
      k_eff_sp[volume] := (1-Porosity_p[volume])*k_sp[volume]/k_fp[Volume];
     end else if (RG_geometry.ItemIndex = 1) then begin   //Spheres bed and pins
      f_0 := 0.8 + 0.1*Porosity_p[volume];
      alpha_0 := Power(10,(-1.084 - 6.778*(Porosity_w[volume]-0.298)));
      k_eff_sp[volume] := (((1-alpha_0)*(Porosity_p[volume]*f_0 + //Static thermal conduction - (HADLEY, 1986)
                           (k_sp[volume]/k_fp[volume])*
                           (1-Porosity_p[volume]*f_0))/(1-Porosity_p[volume]*
                           (1-f_0)+(k_sp[volume]/k_fp[volume])*
                           Porosity_p[volume]*(1-f_0))+alpha_0*
                           (2*(Power((k_sp[volume]/k_fp[volume]),2))*
                           (1-Porosity_p[volume])+(1+2*Porosity_p[volume])*
                           (k_sp[volume]/k_fp[volume]))/((2+Porosity_p[volume])*
                           (k_sp[volume]/k_fp[volume])+1-Porosity_p[volume])));
     end else if (RG_geometry.ItemIndex = 2) then begin                         //Kaviany
      k_eff_sp[volume] := (Power(1 - Porosity_p[volume],0.5)*k_sp[volume])/
                           ((1 - Power(1-Porosity_p[volume],0.5))*k_sp[volume] +
                           Power(1-Porosity_p[volume],0.5)*k_fp[volume]);
     end;
     k_eff_sp[volume] := k_eff_sp[volume]*k_fp[volume];

    Length_dlss := Length_dlss + Delta_L_dlss;
    end;
    //end fluid and solid properties



    //AIR 1 Solver
    //Mesh Scan in z direction
    For Volume := 0 to MeshSize+1 do begin

     if (volume > 0) and (volume < MeshSize+1) then begin //if volumes internos onde recebe q_flux e h_conv
      //Border temperature
      Theta_border[volume] := ((T_air_1old[Volume,0]+T_air_1old[Volume,1])/2);

      //Air Properties
      T_air_f[Volume] := Theta_border[volume]*T_spam+T_CHEX;
      rho_airp[Volume] := 3.6562 - 0.0127506*T_air_f[Volume] + 0.0000147769*Power(T_air_f[Volume],2);
      mu_airp[Volume] := 0.00000103335 + 7.02638*Power(10,-8)*T_air_f[Volume] - 3.931299*Power(10,-11)*Power(T_air_f[Volume],2);
      k_airp[Volume] := 0.00317628 + 0.0000748813*T_air_f[Volume];
      cp_airp[volume] := 1016.99 - 0.131014*T_air_f[Volume] + 0.000300327*Power(T_air_f[Volume],2);
      nu_airp[Volume] := mu_airp[Volume]/rho_airp[Volume];
      dif_airp[volume] := k_airp[Volume]/(rho_airp[Volume]*cp_airp[volume]);
      Pr_airp[Volume] := nu_airp[Volume]/dif_airp[volume];
      //End Air Properties
            


      //Condicao de contorno para o NORTE camada de at - > T = Tamb


      //Condicao de contorno para o SUL da camada de ar
     T_BC_wallAir[Volume] := ((k_airp[volume]/delta_air1)*T_air_1old[Volume,1]+
                              (k_y_wall1/Delta_y1)*T_wall_1old[Volume,mesh_wall1])/
                          ((k_y_wall1/Delta_y1) + (k_airp[volume]/delta_air1));

      end; //end if volumes internos onde recebe q_flux e h_conv

     //Matrix coeficients

      if volume = 0 then begin  //CC em West
       For volume_y := 1 to mesh_air1 do begin
        A_Lw[Volume,volume_y]:=0;
        A_Le[Volume,volume_y]:=1;
        A_Ln[Volume,volume_y]:=0;
        A_Ls[Volume,volume_y]:=0;
        A_Lp[Volume,volume_y]:= 1;
        B_Lp[Volume,volume_y]:= 0;
       end;
      end else if volume = MeshSize+1 then begin //CC em East
       For volume_y := 1 to mesh_air1 do begin
        A_Lw[Volume,volume_y]:=1;
        A_Le[Volume,volume_y]:=0;
        A_Ln[Volume,volume_y]:=0;
        A_Ls[Volume,volume_y]:=0;
        A_Lp[Volume,volume_y]:= 1;
        B_Lp[Volume,volume_y]:= 0;
       end;
      end else begin //volumes internos em z
       For volume_y := 0 to mesh_air1+1 do begin
        if volume_y = 0 then begin //CC sul
         A_Lw[Volume,volume_y]:=0;
         A_Le[Volume,volume_y]:=0;
         A_Ln[Volume,volume_y]:= - 1;
         A_Ls[Volume,volume_y]:=0;
         A_Lp[Volume,volume_y]:= 1;
         B_Lp[Volume,volume_y]:= 2*T_BC_wallAir[Volume];
        end else if volume_y = mesh_air1+1 then begin //CC Norte
         A_Lw[Volume,volume_y]:=0;
         A_Le[Volume,volume_y]:=0;
         A_Ln[Volume,volume_y]:=0;
         A_Ls[Volume,volume_y]:= -1;
         A_Lp[Volume,volume_y]:= 1;
         B_Lp[Volume,volume_y]:= 2*Theta_amb;
        end else begin //volumes internos em y
         A_Lw[Volume,volume_y]:=(dif_z_wall1/(omega*Power(L_casing,2)))*(delta_air1_dlss/Delta_L_dlss);
         A_Le[Volume,volume_y]:=(dif_z_wall1/(omega*Power(L_casing,2)))*(delta_air1_dlss/Delta_L_dlss);
         A_Ln[Volume,volume_y]:=(dif_airp[volume]/(omega*Power(e_air1,2)))*(Delta_L_dlss/delta_air1_dlss);
         A_Ls[Volume,volume_y]:=(dif_airp[volume]/(omega*Power(e_air1,2)))*(Delta_L_dlss/delta_air1_dlss);
         A_Lp[Volume,volume_y]:= A_Lw[Volume,volume_y] + A_Le[Volume,volume_y] +
                                 A_Ln[Volume,volume_y] + A_Ls[Volume,volume_y] +
                                (Delta_L_dlss*delta_air1_dlss)/Delta_time_dlss;
        // B_Lp[Volume,volume_y]:= T_air1_TSBefore[Volume,volume_y]*(Delta_L_dlss*delta_air1_dlss)/Delta_time_dlss +
          //                      (mu_airp[Volume]/(rho_airp[Volume]*cp_airp[volume]*omega*T_spam))*Power(omega*(D_Magnet_in/2)/e_air1,2)*(Delta_L_dlss*delta_air1_dlss);
         B_Lp[Volume,volume_y]:= T_air1_TSBefore[Volume,volume_y]*(Delta_L_dlss*delta_air1_dlss)/Delta_time_dlss +
                                f_correction*(mu_airp[Volume]/(rho_airp[Volume]*cp_airp[volume]*(omega*f_Magnet/frequency)*T_spam))*Power((omega*f_Magnet/frequency)*(D_Magnet_in/2)/e_air1,2)*(Delta_L_dlss*delta_air1_dlss);
        end;
       end;
      end;


    end;
    //End Mesh Scan in z

    //TDMA coeficients
    For Volume := 0 to MeshSize+1 do begin
     if volume = 0 then begin
      For volume_y := 1 to mesh_air1 do begin
       if volume_y = 1 then begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Le[Volume,volume_y]*T_air_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];
       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       Qm_wall[Volume,volume_y] := D_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       end else begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Le[Volume,volume_y]*T_air_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];

       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       Qm_wall[Volume,volume_y] :=  (D_tdma[Volume,volume_y] - C_tdma[Volume,volume_y]*Qm_wall[Volume,volume_y-1])/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       end;
      end;
     end   //end if volume=0
     else if volume = MeshSize+1 then begin
      For volume_y := 1 to mesh_air1 do begin
       if volume_y = 1 then begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_air_1old[Volume-1,volume_y] + B_Lp[Volume,volume_y];
       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       Qm_wall[Volume,volume_y] := D_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       end else begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_air_1old[Volume-1,volume_y] + B_Lp[Volume,volume_y];

       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       Qm_wall[Volume,volume_y] :=  (D_tdma[Volume,volume_y] - C_tdma[Volume,volume_y]*Qm_wall[Volume,volume_y-1])/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       end;
      end;
     end   //end if volume=MeshSize+1
     else begin
      For volume_y := 0 to mesh_air1+1 do begin
       if volume_y = 0 then begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_air_1old[Volume-1,volume_y] + A_Le[Volume,volume_y]*T_air_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];
       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       Qm_wall[Volume,volume_y] := D_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       end else begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_air_1old[Volume-1,volume_y] + A_Le[Volume,volume_y]*T_air_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];

       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       Qm_wall[Volume,volume_y] :=  (D_tdma[Volume,volume_y] - C_tdma[Volume,volume_y]*Qm_wall[Volume,volume_y-1])/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       end;
      end;
     end;   //end if volume=internos
    end; //en varredura para calcular Pm e Qm do TDMA

    //Solver wall 1
    For Volume := 0 to MeshSize+1 do begin
     if volume = 0 then begin
      For volume_y := mesh_air1 downto 1 do begin
       if volume_y = mesh_air1 then begin
        T_air_1[Volume,volume_y] := Qm_wall[Volume,volume_y];
       end else begin
        T_air_1[Volume,volume_y] := Pm_wall[Volume,volume_y]*T_air_1[Volume,volume_y+1] + Qm_wall[Volume,volume_y];
       end;
      end;
     end else if volume = MeshSize+1 then begin
      For volume_y := mesh_air1 downto 1 do begin
       if volume_y = mesh_air1 then begin
        T_air_1[Volume,volume_y] := Qm_wall[Volume,volume_y];
       end else begin
        T_air_1[Volume,volume_y] := Pm_wall[Volume,volume_y]*T_air_1[Volume,volume_y+1] + Qm_wall[Volume,volume_y];
       end;
      end;
     end else begin
      For volume_y := mesh_air1+1 downto 0 do begin
       if volume_y = mesh_air1+1 then begin
        T_air_1[Volume,volume_y] := Qm_wall[Volume,volume_y];
       end else begin
        T_air_1[Volume,volume_y] := Pm_wall[Volume,volume_y]*T_air_1[Volume,volume_y+1] + Qm_wall[Volume,volume_y];
       end;
      end;
     end;
    end;
    //end solver wall 1





    //Wall 1 Solver
    //Mesh Scan in z direction
    For Volume := 0 to MeshSize+1 do begin

     if (volume > 0) and (volume < MeshSize+1) then begin //if volumes internos onde recebe q_flux e h_conv
      //Border temperature
      Theta_border[volume] := ((T_air_1[Volume,0]+T_air_1[Volume,1])/2);

      //Air Properties
      T_air_f[Volume] := Theta_border[volume]*T_spam+T_CHEX;
      rho_airp[Volume] := 3.6562 - 0.0127506*T_air_f[Volume] + 0.0000147769*Power(T_air_f[Volume],2);
      mu_airp[Volume] := 0.00000103335 + 7.02638*Power(10,-8)*T_air_f[Volume] - 3.931299*Power(10,-11)*Power(T_air_f[Volume],2);
      k_airp[Volume] := 0.00317628 + 0.0000748813*T_air_f[Volume];
      cp_airp[volume] := 1016.99 - 0.131014*T_air_f[Volume] + 0.000300327*Power(T_air_f[Volume],2);
      nu_airp[Volume] := mu_airp[Volume]/rho_airp[Volume];
      dif_airp[volume] := k_airp[Volume]/(rho_airp[Volume]*cp_airp[volume]);
      Pr_airp[Volume] := nu_airp[Volume]/dif_airp[volume];
      //End Air Properties


     //Velocities upload for volumes e condicao de contorno


    //BC
    Efvd_f[volume] := Power(k_fp[volume]*cp_fp[volume]*rho_fp[volume],0.5);
    Efvd_s[volume] := Power(k_sp[volume]*cp_sp[volume]*rho_sp[volume],0.5);
    if RG_geometry.ItemIndex = 0 then begin     //Parallel Plates
     if u_D_dlss[Cont_time_cycle,volume] = 0 then begin
      u_wall := 0;
    //  T_BC_wall_PM[Volume] := (k_y_wall1*T_wall_1old[Volume,1] + k_fp[volume]*T_fp[volume])/(k_y_wall1 + k_fp[volume]) ;

      T_BC_wall_PM[Volume] := (Efvd_y_wall1*T_BC_wallAir[Volume] + (1 - Porosity_p[volume])*Efvd_s[volume]*T_sp[volume] + Porosity_p[volume]*Efvd_f[volume]*T_fp[volume])/
                              (Efvd_y_wall1 + (1 - Porosity_p[volume])*Efvd_s[volume] + Porosity_p[volume]*Efvd_f[volume]);

     end else begin
       h_conv_PM[volume] := 7.541*k_fp[Volume]/Dh_p[volume];
     end;

    end else if RG_geometry.ItemIndex = 1 then begin     //spehres

     if u_D_dlss[Cont_time_cycle,volume] = 0 then begin
      u_wall := 0;
     // T_BC_wall_PM[Volume] := (k_y_wall1*T_wall_1old[Volume,1] + k_fp[volume]*T_fp[volume])/(k_y_wall1 + k_fp[volume]) ;
       T_BC_wall_PM[Volume] := (Efvd_y_wall1*T_BC_wallAir[Volume] + (1 - Porosity_p[volume])*Efvd_s[volume]*T_sp[volume] + Porosity_p[volume]*Efvd_f[volume]*T_fp[volume])/
                              (Efvd_y_wall1 + (1 - Porosity_p[volume])*Efvd_s[volume] + Porosity_p[volume]*Efvd_f[volume]);

     end else if u_D_dlss[Cont_time_cycle,volume] > 0 then begin
      if Form_HeatLosses.RG_Nu_HeatWall.ItemIndex = 0 then begin
       h_conv_PM[volume] := 5.78*k_eff_sp[volume]/D_face;     //Bejan
      end else begin
       u_wall := u_CB[Cont_time_cycle,volume];
       Re_wall[volume] := ABS(u_wall)*Dp_p[volume]/nu_fp[Volume]; //Li
       h_conv_PM[volume] := 0.17*Power(Re_wall[volume],0.79)*k_fp[Volume]/Dp_p[volume];
      end;
     end else begin
      if Form_HeatLosses.RG_Nu_HeatWall.ItemIndex = 0 then begin
       h_conv_PM[volume] := 5.78*k_eff_sp[volume]/D_face;     //Bejan
      end else begin
       u_wall := u_HB[Cont_time_cycle,volume];
       Re_wall[volume] := ABS(u_wall)*Dp_p[volume]/nu_fp[Volume]; //Li
       h_conv_PM[volume] := 0.17*Power(Re_wall[volume],0.79)*k_fp[Volume]/Dp_p[volume];
      end;
     end;

    end else if RG_geometry.ItemIndex = 2 then begin     //pins

      if u_D_dlss[Cont_time_cycle,volume] = 0 then begin
      u_wall := 0;
     // T_BC_wall_PM[Volume] := (k_y_wall1*T_wall_1old[Volume,1] + k_fp[volume]*T_fp[volume])/(k_y_wall1 + k_fp[volume]) ;
      T_BC_wall_PM[Volume] := (Efvd_y_wall1*T_BC_wallAir[Volume] + (1 - Porosity_p[volume])*Efvd_s[volume]*T_sp[volume] + Porosity_p[volume]*Efvd_f[volume]*T_fp[volume])/
                              (Efvd_y_wall1 + (1 - Porosity_p[volume])*Efvd_s[volume] + Porosity_p[volume]*Efvd_f[volume]);

     end else if u_D_dlss[Cont_time_cycle,volume] > 0 then begin
       u_wall := u_CB[Cont_time_cycle,volume];
       Re_wall[volume] := ABS(u_wall)*Dp_p[volume]/nu_fp[Volume]; //Li
       h_conv_PM[volume] := 0.16*Power(Re_wall[volume],0.93)*k_fp[Volume]/Dp_p[volume];
     end else begin
       u_wall := u_HB[Cont_time_cycle,volume];
       Re_wall[volume] := ABS(u_wall)*Dp_p[volume]/nu_fp[Volume]; //Li
       h_conv_PM[volume] := 0.16*Power(Re_wall[volume],0.93)*k_fp[Volume]/Dp_p[volume];
     end;
    end;
    //End Velocities upload for volumes




      //Condicao de contorno para o Meio Poroso
     T_BC_wallAir[Volume] := ((k_airp[volume]/delta_air1)*T_air_1[Volume,1]+
                              (k_y_wall1/Delta_y1)*T_wall_1old[Volume,mesh_wall1])/
                          ((k_y_wall1/Delta_y1) + (k_airp[volume]/delta_air1));
      end; //end if volumes internos onde recebe q_flux e h_conv

     //Matrix coeficients

      if volume = 0 then begin  //CC em West
       For volume_y := 1 to mesh_wall1 do begin
        A_Lw[Volume,volume_y]:=0;
        A_Le[Volume,volume_y]:=1;
        A_Ln[Volume,volume_y]:=0;
        A_Ls[Volume,volume_y]:=0;
        A_Lp[Volume,volume_y]:= 1;
        B_Lp[Volume,volume_y]:= 0;
       end;
      end else if volume = MeshSize+1 then begin //CC em East
       For volume_y := 1 to mesh_wall1 do begin
        A_Lw[Volume,volume_y]:=1;
        A_Le[Volume,volume_y]:=0;
        A_Ln[Volume,volume_y]:=0;
        A_Ls[Volume,volume_y]:=0;
        A_Lp[Volume,volume_y]:= 1;
        B_Lp[Volume,volume_y]:= 0;
       end;
      end else begin //volumes internos em z
       For volume_y := 0 to mesh_wall1+1 do begin
        if volume_y = 0 then begin //CC sul
         if u_wall = 0 then begin  //--->> Fluido parado
          A_Lw[Volume,volume_y]:=0;
          A_Le[Volume,volume_y]:=0;
          A_Ln[Volume,volume_y]:=-1;
          A_Ls[Volume,volume_y]:= 0;
          A_Lp[Volume,volume_y]:= 1;
          B_Lp[Volume,volume_y]:= 2*T_BC_wall_PM[Volume];
         end else begin   //--->> Fluido escoando
          A_Lw[Volume,volume_y]:=0;
          A_Le[Volume,volume_y]:=0;
          A_Ln[Volume,volume_y]:= - (h_conv_PM[volume]/2) + (k_y_wall1/Delta_y1);
          A_Ls[Volume,volume_y]:=0;
          A_Lp[Volume,volume_y]:= (h_conv_PM[volume]/2) + (k_y_wall1/Delta_y1);
          B_Lp[Volume,volume_y]:= h_conv_PM[volume]*T_fp[volume];
         end;
        end else if volume_y = mesh_wall1+1 then begin //CC Norte
         A_Lw[Volume,volume_y]:=0;
         A_Le[Volume,volume_y]:=0;
         A_Ln[Volume,volume_y]:=0;
         A_Ls[Volume,volume_y]:= -1;
         A_Lp[Volume,volume_y]:= 1;
         B_Lp[Volume,volume_y]:= 2*T_BC_wallAir[Volume];
        end else begin //volumes internos em y
         A_Lw[Volume,volume_y]:=(dif_z_wall1/(omega*Power(L_casing,2)))*(Delta_y1_dlss/Delta_L_dlss);
         A_Le[Volume,volume_y]:=(dif_z_wall1/(omega*Power(L_casing,2)))*(Delta_y1_dlss/Delta_L_dlss);
         A_Ln[Volume,volume_y]:=(dif_y_wall1/(omega*Power(e_wall1,2)))*(Delta_L_dlss/Delta_y1_dlss);
         A_Ls[Volume,volume_y]:=(dif_y_wall1/(omega*Power(e_wall1,2)))*(Delta_L_dlss/Delta_y1_dlss);
         A_Lp[Volume,volume_y]:= A_Lw[Volume,volume_y] + A_Le[Volume,volume_y] +
                                 A_Ln[Volume,volume_y] + A_Ls[Volume,volume_y] +
                                (Delta_L_dlss*Delta_y1_dlss)/Delta_time_dlss;
         B_Lp[Volume,volume_y]:= T_wall1_TSBefore[Volume,volume_y]*(Delta_L_dlss*Delta_y1_dlss)/Delta_time_dlss;
        end;
       end;
      end;


    end;
    //End Mesh Scan in z

    //TDMA coeficients
    For Volume := 0 to MeshSize+1 do begin
     if volume = 0 then begin
      For volume_y := 1 to mesh_wall1 do begin
       if volume_y = 1 then begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Le[Volume,volume_y]*T_wall_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];
       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       Qm_wall[Volume,volume_y] := D_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       end else begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Le[Volume,volume_y]*T_wall_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];

       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       Qm_wall[Volume,volume_y] :=  (D_tdma[Volume,volume_y] - C_tdma[Volume,volume_y]*Qm_wall[Volume,volume_y-1])/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       end;
      end;
     end   //end if volume=0
     else if volume = MeshSize+1 then begin
      For volume_y := 1 to mesh_wall1 do begin
       if volume_y = 1 then begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_wall_1old[Volume-1,volume_y] + B_Lp[Volume,volume_y];
       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       Qm_wall[Volume,volume_y] := D_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       end else begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_wall_1old[Volume-1,volume_y] + B_Lp[Volume,volume_y];

       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       Qm_wall[Volume,volume_y] :=  (D_tdma[Volume,volume_y] - C_tdma[Volume,volume_y]*Qm_wall[Volume,volume_y-1])/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       end;
      end;
     end   //end if volume=MeshSize+1
     else begin
      For volume_y := 0 to mesh_wall1+1 do begin
       if volume_y = 0 then begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_wall_1old[Volume-1,volume_y] + A_Le[Volume,volume_y]*T_wall_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];
       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       Qm_wall[Volume,volume_y] := D_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       end else begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_wall_1old[Volume-1,volume_y] + A_Le[Volume,volume_y]*T_wall_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];

       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       Qm_wall[Volume,volume_y] :=  (D_tdma[Volume,volume_y] - C_tdma[Volume,volume_y]*Qm_wall[Volume,volume_y-1])/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       end;
      end;
     end;   //end if volume=internos
    end; //en varredura para calcular Pm e Qm do TDMA

    //Solver wall 1
    For Volume := 0 to MeshSize+1 do begin
     if volume = 0 then begin
      For volume_y := mesh_wall1 downto 1 do begin
       if volume_y = mesh_wall1 then begin
        T_wall_1[Volume,volume_y] := Qm_wall[Volume,volume_y];
       end else begin
        T_wall_1[Volume,volume_y] := Pm_wall[Volume,volume_y]*T_wall_1[Volume,volume_y+1] + Qm_wall[Volume,volume_y];
       end;
      end;
     end else if volume = MeshSize+1 then begin
      For volume_y := mesh_wall1 downto 1 do begin
       if volume_y = mesh_wall1 then begin
        T_wall_1[Volume,volume_y] := Qm_wall[Volume,volume_y];
       end else begin
        T_wall_1[Volume,volume_y] := Pm_wall[Volume,volume_y]*T_wall_1[Volume,volume_y+1] + Qm_wall[Volume,volume_y];
       end;
      end;
     end else begin
      For volume_y := mesh_wall1+1 downto 0 do begin
       if volume_y = mesh_wall1+1 then begin
        T_wall_1[Volume,volume_y] := Qm_wall[Volume,volume_y];
       end else begin
        T_wall_1[Volume,volume_y] := Pm_wall[Volume,volume_y]*T_wall_1[Volume,volume_y+1] + Qm_wall[Volume,volume_y];
       end;
      end;
     end;
    end;
    //end solver wall 1

    //Erro wall 1
    SUM_wall1 := 0;
    For Volume := 1 to MeshSize do begin
     For volume_y :=1 to mesh_wall1 do begin
      SUM_wall1 := SUM_wall1 + Power((T_wall_1[Volume,volume_y] - T_wall_1old[Volume,volume_y]),2);
     end;
    end;

    Erro_Twall_1 := Power(SUM_wall1, 0.5);


    //Erro Air 1
    SUM_air1 := 0;
    For Volume := 1 to MeshSize do begin
     For volume_y :=1 to mesh_air1 do begin
      SUM_air1 := SUM_air1 + Power((T_air_1[Volume,volume_y] - T_air_1old[Volume,volume_y]),2);
     end;
    end;

    Erro_Tair_1 := Power(SUM_air1, 0.5);




    if Cont_Loss_ini < 50 then begin
      if (Erro_Twall_1 < Power(10,-6)) and (Erro_Tair_1 < Power(10,-6)) then begin
      Error_Loss := 1;
      end else begin
      Error_Loss := 0;
      end;
    end else begin
     Error_Loss := 1;
    end;

   end; //end if para 1 camada


    /////////////////////PARA DUAS CAMADAS//////////////////////////////
   if Form_HeatLosses.RG_NoWalls.ItemIndex = 1 then begin   //Neste caso, temos CC em Norte de fluxo constante e em Sul de conveccao e entre camadas de temperatura prescrita

    //saving old temperatures
    For Volume := 0 to MeshSize+1 do begin
      if Cont_Loss_ini = 0 then begin
        for volume_y := 0 to mesh_wall1+1 do begin
         T_wall_1old[Volume,volume_y] := T_wall1_TSBefore[volume,volume_y];
        end;
        for volume_y := 0 to mesh_wall2+1 do begin
         T_wall_2old[Volume,volume_y] := T_wall2_TSBefore[volume,volume_y];
        end;
        for volume_y := 0 to mesh_air1+1 do begin
         T_air_1old[Volume,volume_y] := T_air1_TSBefore[volume,volume_y];
        end;
      end else begin
        for volume_y := 0 to mesh_wall1+1 do begin
         T_wall_1old[Volume,volume_y] := T_wall_1[volume,volume_y];
        end;
        for volume_y := 0 to mesh_wall2+1 do begin
         T_wall_2old[Volume,volume_y] := T_wall_2[volume,volume_y];
        end;
        for volume_y := 0 to mesh_air1+1 do begin
         T_air_1old[Volume,volume_y] := T_air_1[volume,volume_y];
        end;
      end;
    end;


    //Updating Solid and Fluid temperatures and properties
    Length_dlss:= Delta_L_dlss/2;
    For Volume := 0 to MeshSize+1 do begin

     T_fp[volume] := T_fOld[Cont_Int, volume];
     T_sp[volume] := T_sOld[Cont_Int, volume];

     //Working Fluid Properties
     rho_fp[Volume] := - 517.378
                      + 14.3157*(T_fp[volume]*T_spam + T_CHEX)
                      - 0.0440498*Power((T_fp[volume]*T_spam + T_CHEX),2)
                      + 0.0000438395*Power((T_fp[volume]*T_spam + T_CHEX),3);
     mu_fp[Volume] := 0.79913
                   - 0.00976317*(T_fp[volume]*T_spam + T_CHEX)
                   + 0.0000449597*Power((T_fp[volume]*T_spam + T_CHEX),2)
                   - 0.000000092347*Power((T_fp[volume]*T_spam + T_CHEX),3)
                   + 0.0000000000713175*Power((T_fp[volume]*T_spam + T_CHEX),4);
     k_fp[Volume] := - 0.680944
                    + 0.00687609*(T_fp[volume]*T_spam + T_CHEX)
                    - 0.00000871265*Power((T_fp[volume]*T_spam + T_CHEX),2);

     if (T_fp[volume]*T_spam + T_CHEX) < 293 then begin
     cp_fp[volume] := 245103
                     - 2503.25*(T_fp[volume]*T_spam + T_CHEX)
                     + 8.67151*Power((T_fp[volume]*T_spam + T_CHEX),2)
                     - 0.0100147*Power((T_fp[volume]*T_spam + T_CHEX),3);
     end else begin
     cp_fp[volume] := 4184;
     end;
     nu_fp[Volume] := mu_fp[Volume]/rho_fp[Volume];
     dif_fp[volume] := k_fp[Volume]/(rho_fp[Volume]*cp_fp[volume]);
     Pr_fp[Volume] := nu_fp[Volume]/dif_fp[volume];
     //End Fluid Properties

     //Properties correction for water glycol
      if Glycol_vol > 0 then begin
       rho_fp[Volume] := rho_fp[Volume]*
                       (1.089040385
                       - 0.01022673*(T_fp[volume]*T_spam + T_CHEX)
                       + 0.0000312579*Power((T_fp[volume]*T_spam + T_CHEX),2)
                       - 0.000000032614*Power((T_fp[volume]*T_spam + T_CHEX),3)
                       - 0.02518839*Glycol_wt
                       - 0.00060141*Power(Glycol_wt,2))/
                      (1
                       - 0.009426*(T_fp[volume]*T_spam + T_CHEX)
                       + 0.0000289266*Power((T_fp[volume]*T_spam + T_CHEX),2)
                       - 0.000000030449*Power((T_fp[volume]*T_spam + T_CHEX),3)
                       - 0.01825238*Glycol_wt);
       mu_fp[Volume] := mu_fp[Volume]*
                      (- 0.48083137
                       + 0.003165299*(T_fp[volume]*T_spam + T_CHEX)
                       - 0.0000055754*Power((T_fp[volume]*T_spam + T_CHEX),2)
                       - 0.04388738*Glycol_wt
                       - 0.0831036*Power(Glycol_wt,2))/
                      (1
                       - 0.01052098*(T_fp[volume]*T_spam + T_CHEX)
                       + 0.0000362597*Power((T_fp[volume]*T_spam + T_CHEX),2)
                       - 0.000000042298*Power((T_fp[volume]*T_spam + T_CHEX),3)
                       + 0.026624841*Glycol_wt);
       k_fp[Volume] := k_fp[Volume]*
                       (0.769354184
                       - 0.00648959*(T_fp[volume]*T_spam + T_CHEX)
                       - 0.0000040541*Power((T_fp[volume]*T_spam + T_CHEX),2)
                       - 2.86147298*Glycol_wt
                       + 0.060202185*Power(Glycol_wt,2)
                       + 0.010604554*(T_fp[volume]*T_spam + T_CHEX)*Glycol_wt)/
                      (1
                       - 0.00780393*(T_fp[volume]*T_spam + T_CHEX)
                       - 0.0000019933*Power((T_fp[volume]*T_spam + T_CHEX),2)
                       + 0.109891962*Glycol_wt
                       - 0.20530181*Power(Glycol_wt,2)
                       - 0.00296141*(T_fp[volume]*T_spam + T_CHEX)*Glycol_wt);
       cp_fp[volume] := cp_fp[volume]*
                        (15.60442824
                        - 13270.6349/(T_fp[volume]*T_spam + T_CHEX)
                        + 4017470/Power((T_fp[volume]*T_spam + T_CHEX),2)
                        - 405000000/Power((T_fp[volume]*T_spam + T_CHEX),3)
                        + 1.791510444*Glycol_wt
                        - 0.43299511*Power(Glycol_wt,2)
                        - 0.16418117*Power(Glycol_wt,3)
                        - 1061.16827*Glycol_wt/(T_fp[volume]*T_spam + T_CHEX)
                        + 125.020179*Power(Glycol_wt,2)/(T_fp[volume]*T_spam + T_CHEX)
                        + 130141.358*Glycol_wt/Power((T_fp[volume]*T_spam + T_CHEX),2));

       nu_fp[Volume] := mu_fp[Volume]/rho_fp[Volume];
       dif_fp[volume] := k_fp[Volume]/(rho_fp[Volume]*cp_fp[volume]);
       Pr_fp[Volume] := nu_fp[Volume]/dif_fp[volume];
      end;

    //End Fluid Properties

       //Solid Properties
       rho_sp[Volume] := 7900;                                                  //Solid Density
       k_sp[Volume] := 10.5;                                                    //Solid thermal condutivety


        for hh := 1 to malha_campo do begin
         if H_eff[Cont_time_cycle,volume] = MatrixField[hh] then begin
          Ponto_H := hh;
         end;
         if (H_eff[Cont_time_cycle,volume] > MatrixField[hh]) and (H_eff[Cont_time_cycle,volume] < MatrixField[hh+1]) then begin
          Ponto_H := hh;
         end;
        end;

       //1 Layer
       if Form_MagnetocaloricMaterial.RG_NumberofLayers.ItemIndex = 0 then begin
        for tt := 1 to malha_temperatura do begin
         if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L1[tt] then begin
          Ponto_T := tt;
         end;
         if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L1[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L1[tt+1])  then begin
          Ponto_T := tt;
         end;
        end;

       cp_sp[volume]  :=   CHtotal_L1[Ponto_T,Ponto_H]    *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                           CHtotal_L1[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                           CHtotal_L1[Ponto_T,Ponto_H+1]  *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                           CHtotal_L1[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));
       end;
       //end 1 layer

       //2 Layers
       if Form_MagnetocaloricMaterial.RG_NumberofLayers.ItemIndex = 1 then begin
        if ((Length_dlss - Delta_L_dlss/2) < L1_frac) and ((Length_dlss + Delta_L_dlss/2) < L1_frac) then begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L1[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L1[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L1[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

        cp_sp[volume]  :=   CHtotal_L1[Ponto_T,Ponto_H]    *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T,Ponto_H+1]  *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end else if ((Length_dlss - Delta_L_dlss/2) < L1_frac) and ((Length_dlss + Delta_L_dlss/2) > L1_frac) then begin
         Delta_L1 := L1_frac - (Length_dlss - Delta_L_dlss/2);
	       Delta_L2 := Delta_L_dlss - Delta_L1;

         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L1[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L1[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L1[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M1  :=   CHtotal_L1[Ponto_T,Ponto_H]    *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T,Ponto_H+1]  *((MatrixTemp_L1[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L1[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L1[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L1[Ponto_T+1]-MatrixTemp_L1[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L2[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L2[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L2[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

             cp_M2  :=   CHtotal_L2[Ponto_T,Ponto_H]    *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T,Ponto_H+1]  *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

         cp_sp[volume]  :=  (Delta_L1*cp_M1 + Delta_L2*cp_M2)/(Delta_L1+Delta_L2);

        end else begin
         for tt := 1 to malha_temperatura do begin
          if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L2[tt] then begin
           Ponto_T := tt;
          end;
          if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L2[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L2[tt+1])  then begin
           Ponto_T := tt;
          end;
         end;

         cp_sp[volume]  :=   CHtotal_L2[Ponto_T,Ponto_H]    *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T,Ponto_H+1]  *((MatrixTemp_L2[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                            CHtotal_L2[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp_L2[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp_L2[Ponto_T+1]-MatrixTemp_L2[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

        end;
       end;
       //end 2 layers


       { for tt := 1 to malha_temperatura do begin
         if (T_sp[volume]*T_spam + T_CHEX) = MatrixTemp_L1[tt] then begin
          Ponto_T := tt;
         end;
         if ((T_sp[volume]*T_spam + T_CHEX) > MatrixTemp_L1[tt]) and ((T_sp[volume]*T_spam + T_CHEX) < MatrixTemp_L1[tt+1])  then begin
          Ponto_T := tt;
         end;
        end;

       cp_sp[volume]  :=   CHtotal_L1[Ponto_T,Ponto_H]    *((MatrixTemp[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp[Ponto_T+1]-MatrixTemp[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                           CHtotal_L1[Ponto_T+1,Ponto_H]  *(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp[Ponto_T])  *(MatrixField[Ponto_H+1]-H_eff[Cont_time_cycle,volume]))/((MatrixTemp[Ponto_T+1]-MatrixTemp[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                           CHtotal_L1[Ponto_T,Ponto_H+1]  *((MatrixTemp[Ponto_T+1]-(T_sp[volume]*T_spam + T_CHEX))*(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp[Ponto_T+1]-MatrixTemp[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H])) +
                           CHtotal_L1[Ponto_T+1,Ponto_H+1]*(((T_sp[volume]*T_spam + T_CHEX)-MatrixTemp[Ponto_T])  *(H_eff[Cont_time_cycle,volume]-MatrixField[Ponto_H]))  /((MatrixTemp[Ponto_T+1]-MatrixTemp[Ponto_T])*(MatrixField[Ponto_H+1]-MatrixField[Ponto_H]));

          }
     //Effective thermal conduction
     if (RG_geometry.ItemIndex = 0) or (RG_geometry.ItemIndex = 3) then begin   //Parallel Plates and Microchannels
      k_eff_sp[volume] := (1-Porosity_p[volume])*k_sp[volume]/k_fp[Volume];
     end else if (RG_geometry.ItemIndex = 1) then begin   //Spheres bed and pins
      f_0 := 0.8 + 0.1*Porosity_p[volume];
      alpha_0 := Power(10,(-1.084 - 6.778*(Porosity_w[volume]-0.298)));
      k_eff_sp[volume] := (((1-alpha_0)*(Porosity_p[volume]*f_0 + //Static thermal conduction - (HADLEY, 1986)
                           (k_sp[volume]/k_fp[volume])*
                           (1-Porosity_p[volume]*f_0))/(1-Porosity_p[volume]*
                           (1-f_0)+(k_sp[volume]/k_fp[volume])*
                           Porosity_p[volume]*(1-f_0))+alpha_0*
                           (2*(Power((k_sp[volume]/k_fp[volume]),2))*
                           (1-Porosity_p[volume])+(1+2*Porosity_p[volume])*
                           (k_sp[volume]/k_fp[volume]))/((2+Porosity_p[volume])*
                           (k_sp[volume]/k_fp[volume])+1-Porosity_p[volume])));
     end else if (RG_geometry.ItemIndex = 2) then begin                         //Kaviany
      k_eff_sp[volume] := (Power(1 - Porosity_p[volume],0.5)*k_sp[volume])/
                           ((1 - Power(1-Porosity_p[volume],0.5))*k_sp[volume] +
                           Power(1-Porosity_p[volume],0.5)*k_fp[volume]);
     end;
     k_eff_sp[volume] := k_eff_sp[volume]*k_fp[volume];

    Length_dlss := Length_dlss + Delta_L_dlss;
    end;
    //end fluid and solid properties




    //AIR 1 Solver
    //Mesh Scan in z direction
    For Volume := 0 to MeshSize+1 do begin

    if (volume > 0) and (volume < MeshSize+1) then begin //if volumes internos onde recebe q_flux e h_conv
      //Border temperature
      Theta_border[volume] := ((T_air_1old[Volume,0]+T_air_1old[Volume,1])/2);

      //Air Properties
      T_air_f[Volume] := Theta_border[volume]*T_spam+T_CHEX;
      rho_airp[Volume] := 3.6562 - 0.0127506*T_air_f[Volume] + 0.0000147769*Power(T_air_f[Volume],2);
      mu_airp[Volume] := 0.00000103335 + 7.02638*Power(10,-8)*T_air_f[Volume] - 3.931299*Power(10,-11)*Power(T_air_f[Volume],2);
      k_airp[Volume] := 0.00317628 + 0.0000748813*T_air_f[Volume];
      cp_airp[volume] := 1016.99 - 0.131014*T_air_f[Volume] + 0.000300327*Power(T_air_f[Volume],2);
      nu_airp[Volume] := mu_airp[Volume]/rho_airp[Volume];
      dif_airp[volume] := k_airp[Volume]/(rho_airp[Volume]*cp_airp[volume]);
      Pr_airp[Volume] := nu_airp[Volume]/dif_airp[volume];
      //End Air Properties



      //Condicao de contorno para o NORTE camada de at - > T = Tamb


      //Condicao de contorno para o SUL da camada de ar
     T_BC_wallAir[Volume] := ((k_airp[volume]/delta_air1)*T_air_1old[Volume,1]+
                              (k_y_wall1/Delta_y1)*T_wall_1old[Volume,mesh_wall1])/
                          ((k_y_wall1/Delta_y1) + (k_airp[volume]/delta_air1));

    end; //end if volumes internos onde recebe q_flux e h_conv

     //Matrix coeficients

      if volume = 0 then begin  //CC em West
       For volume_y := 1 to mesh_air1 do begin
        A_Lw[Volume,volume_y]:=0;
        A_Le[Volume,volume_y]:=1;
        A_Ln[Volume,volume_y]:=0;
        A_Ls[Volume,volume_y]:=0;
        A_Lp[Volume,volume_y]:= 1;
        B_Lp[Volume,volume_y]:= 0;
       end;
      end else if volume = MeshSize+1 then begin //CC em East
       For volume_y := 1 to mesh_air1 do begin
        A_Lw[Volume,volume_y]:=1;
        A_Le[Volume,volume_y]:=0;
        A_Ln[Volume,volume_y]:=0;
        A_Ls[Volume,volume_y]:=0;
        A_Lp[Volume,volume_y]:= 1;
        B_Lp[Volume,volume_y]:= 0;
       end;
      end else begin //volumes internos em z
       For volume_y := 0 to mesh_air1+1 do begin
        if volume_y = 0 then begin //CC sul
         A_Lw[Volume,volume_y]:=0;
         A_Le[Volume,volume_y]:=0;
         A_Ln[Volume,volume_y]:= - 1;
         A_Ls[Volume,volume_y]:=0;
         A_Lp[Volume,volume_y]:= 1;
         B_Lp[Volume,volume_y]:= 2*T_BC_wallAir[Volume];
        end else if volume_y = mesh_air1+1 then begin //CC Norte
         A_Lw[Volume,volume_y]:=0;
         A_Le[Volume,volume_y]:=0;
         A_Ln[Volume,volume_y]:=0;
         A_Ls[Volume,volume_y]:= -1;
         A_Lp[Volume,volume_y]:= 1;
         B_Lp[Volume,volume_y]:= 2*Theta_amb;
        end else begin //volumes internos em y
         A_Lw[Volume,volume_y]:=(dif_z_wall1/(omega*Power(L_casing,2)))*(delta_air1_dlss/Delta_L_dlss);
         A_Le[Volume,volume_y]:=(dif_z_wall1/(omega*Power(L_casing,2)))*(delta_air1_dlss/Delta_L_dlss);
         A_Ln[Volume,volume_y]:=(dif_airp[volume]/(omega*Power(e_air1,2)))*(Delta_L_dlss/delta_air1_dlss);
         A_Ls[Volume,volume_y]:=(dif_airp[volume]/(omega*Power(e_air1,2)))*(Delta_L_dlss/delta_air1_dlss);
         A_Lp[Volume,volume_y]:= A_Lw[Volume,volume_y] + A_Le[Volume,volume_y] +
                                 A_Ln[Volume,volume_y] + A_Ls[Volume,volume_y] +
                                (Delta_L_dlss*delta_air1_dlss)/Delta_time_dlss;
        // B_Lp[Volume,volume_y]:= T_air1_TSBefore[Volume,volume_y]*(Delta_L_dlss*delta_air1_dlss)/Delta_time_dlss +
        //                        (mu_airp[Volume]/(rho_airp[Volume]*cp_airp[volume]*omega*T_spam))*Power(omega*(D_Magnet_in/2)/e_air1,2)*(Delta_L_dlss*delta_air1_dlss);
         B_Lp[Volume,volume_y]:= T_air1_TSBefore[Volume,volume_y]*(Delta_L_dlss*delta_air1_dlss)/Delta_time_dlss +
                                f_correction*(mu_airp[Volume]/(rho_airp[Volume]*cp_airp[volume]*(omega*f_Magnet/frequency)*T_spam))*Power((omega*f_Magnet/frequency)*(D_Magnet_in/2)/e_air1,2)*(Delta_L_dlss*delta_air1_dlss);
        end;
       end;
      end;


    end;
    //End Mesh Scan in z

    //TDMA coeficients
    For Volume := 0 to MeshSize+1 do begin
     if volume = 0 then begin
      For volume_y := 1 to mesh_air1 do begin
       if volume_y = 1 then begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Le[Volume,volume_y]*T_air_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];
       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       Qm_wall[Volume,volume_y] := D_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       end else begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Le[Volume,volume_y]*T_air_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];

       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       Qm_wall[Volume,volume_y] :=  (D_tdma[Volume,volume_y] - C_tdma[Volume,volume_y]*Qm_wall[Volume,volume_y-1])/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       end;
      end;
     end   //end if volume=0
     else if volume = MeshSize+1 then begin
      For volume_y := 1 to mesh_air1 do begin
       if volume_y = 1 then begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_air_1old[Volume-1,volume_y] + B_Lp[Volume,volume_y];
       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       Qm_wall[Volume,volume_y] := D_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       end else begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_air_1old[Volume-1,volume_y] + B_Lp[Volume,volume_y];

       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       Qm_wall[Volume,volume_y] :=  (D_tdma[Volume,volume_y] - C_tdma[Volume,volume_y]*Qm_wall[Volume,volume_y-1])/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       end;
      end;
     end   //end if volume=MeshSize+1
     else begin
      For volume_y := 0 to mesh_air1+1 do begin
       if volume_y = 0 then begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_air_1old[Volume-1,volume_y] + A_Le[Volume,volume_y]*T_air_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];
       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       Qm_wall[Volume,volume_y] := D_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       end else begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_air_1old[Volume-1,volume_y] + A_Le[Volume,volume_y]*T_air_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];

       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       Qm_wall[Volume,volume_y] :=  (D_tdma[Volume,volume_y] - C_tdma[Volume,volume_y]*Qm_wall[Volume,volume_y-1])/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       end;
      end;
     end;   //end if volume=internos
    end; //en varredura para calcular Pm e Qm do TDMA

    //Solver wall 1
    For Volume := 0 to MeshSize+1 do begin
     if volume = 0 then begin
      For volume_y := mesh_air1 downto 1 do begin
       if volume_y = mesh_air1 then begin
        T_air_1[Volume,volume_y] := Qm_wall[Volume,volume_y];
       end else begin
        T_air_1[Volume,volume_y] := Pm_wall[Volume,volume_y]*T_air_1[Volume,volume_y+1] + Qm_wall[Volume,volume_y];
       end;
      end;
     end else if volume = MeshSize+1 then begin
      For volume_y := mesh_air1 downto 1 do begin
       if volume_y = mesh_air1 then begin
        T_air_1[Volume,volume_y] := Qm_wall[Volume,volume_y];
       end else begin
        T_air_1[Volume,volume_y] := Pm_wall[Volume,volume_y]*T_air_1[Volume,volume_y+1] + Qm_wall[Volume,volume_y];
       end;
      end;
     end else begin
      For volume_y := mesh_air1+1 downto 0 do begin
       if volume_y = mesh_air1+1 then begin
        T_air_1[Volume,volume_y] := Qm_wall[Volume,volume_y];
       end else begin
        T_air_1[Volume,volume_y] := Pm_wall[Volume,volume_y]*T_air_1[Volume,volume_y+1] + Qm_wall[Volume,volume_y];
       end;
      end;
     end;
    end;
    //end solver AIR 1






    //Wall 1 Solver
    //Mesh Scan in z direction
    For Volume := 0 to MeshSize+1 do begin

     if (volume > 0) and (volume < MeshSize+1) then begin //if volumes internos onde recebe q_flux e h_conv
      //Border temperature
      Theta_border[volume] := ((T_air_1[Volume,0]+T_air_1[Volume,1])/2);

      //Air Properties
      T_air_f[Volume] := Theta_border[volume]*T_spam+T_CHEX;
      rho_airp[Volume] := 3.6562 - 0.0127506*T_air_f[Volume] + 0.0000147769*Power(T_air_f[Volume],2);
      mu_airp[Volume] := 0.00000103335 + 7.02638*Power(10,-8)*T_air_f[Volume] - 3.931299*Power(10,-11)*Power(T_air_f[Volume],2);
      k_airp[Volume] := 0.00317628 + 0.0000748813*T_air_f[Volume];
      cp_airp[volume] := 1016.99 - 0.131014*T_air_f[Volume] + 0.000300327*Power(T_air_f[Volume],2);
      nu_airp[Volume] := mu_airp[Volume]/rho_airp[Volume];
      dif_airp[volume] := k_airp[Volume]/(rho_airp[Volume]*cp_airp[volume]);
      Pr_airp[Volume] := nu_airp[Volume]/dif_airp[volume];
      //End Air Properties

      //Condicao de contorno para o ar externo
      T_BC_wallAir[Volume] := ((k_airp[volume]/delta_air1)*T_air_1[Volume,1]+
                              (k_y_wall1/Delta_y1)*T_wall_1old[Volume,mesh_wall1])/
                          ((k_y_wall1/Delta_y1) + (k_airp[volume]/delta_air1));

      //Condicao de contorno de temperaturaCC para camada 1 - SUL

     T_1BC[Volume] := ((k_y_wall1/Delta_y1)*T_wall_1old[Volume,1] +
                       (k_y_wall2/Delta_y2)*T_wall_2old[Volume,mesh_wall2])/
                      ((k_y_wall1/Delta_y1) + (k_y_wall2/Delta_y2));
     end; //end if volumes internos onde recebe q_flux e h_conv

     //Matrix coeficients

      if volume = 0 then begin  //CC em West
       For volume_y := 1 to mesh_wall1 do begin
        A_Lw[Volume,volume_y]:=0;
        A_Le[Volume,volume_y]:=1;
        A_Ln[Volume,volume_y]:=0;
        A_Ls[Volume,volume_y]:=0;
        A_Lp[Volume,volume_y]:= 1;
        B_Lp[Volume,volume_y]:= 0;
       end;
      end else if volume = MeshSize+1 then begin //CC em East
       For volume_y := 1 to mesh_wall1 do begin
        A_Lw[Volume,volume_y]:=1;
        A_Le[Volume,volume_y]:=0;
        A_Ln[Volume,volume_y]:=0;
        A_Ls[Volume,volume_y]:=0;
        A_Lp[Volume,volume_y]:= 1;
        B_Lp[Volume,volume_y]:= 0;
       end;
      end else begin //volumes internos em z
       For volume_y := 0 to mesh_wall1+1 do begin
        if volume_y = 0 then begin //CC sul
         A_Lw[Volume,volume_y]:=0;
         A_Le[Volume,volume_y]:=0;
         A_Ln[Volume,volume_y]:= -1;
         A_Ls[Volume,volume_y]:=0;
         A_Lp[Volume,volume_y]:= 1;
         B_Lp[Volume,volume_y]:= 2*T_1BC[Volume];
        end else if volume_y = mesh_wall1+1 then begin //CC Norte
         A_Lw[Volume,volume_y]:=0;
         A_Le[Volume,volume_y]:=0;
         A_Ln[Volume,volume_y]:=0;
         A_Ls[Volume,volume_y]:=-1;
         A_Lp[Volume,volume_y]:= 1;
         B_Lp[Volume,volume_y]:= 2*T_BC_wallAir[Volume];
        end else begin //volumes internos em y
         A_Lw[Volume,volume_y]:=(dif_z_wall1/(omega*Power(L_casing,2)))*(Delta_y1_dlss/Delta_L_dlss);
         A_Le[Volume,volume_y]:=(dif_z_wall1/(omega*Power(L_casing,2)))*(Delta_y1_dlss/Delta_L_dlss);
         A_Ln[Volume,volume_y]:=(dif_y_wall1/(omega*Power(e_wall1,2)))*(Delta_L_dlss/Delta_y1_dlss);
         A_Ls[Volume,volume_y]:=(dif_y_wall1/(omega*Power(e_wall1,2)))*(Delta_L_dlss/Delta_y1_dlss);
         A_Lp[Volume,volume_y]:= A_Lw[Volume,volume_y] + A_Le[Volume,volume_y] +
                                 A_Ln[Volume,volume_y] + A_Ls[Volume,volume_y] +
                                (Delta_L_dlss*Delta_y1_dlss)/Delta_time_dlss;
         B_Lp[Volume,volume_y]:= T_wall1_TSBefore[Volume,volume_y]*(Delta_L_dlss*Delta_y1_dlss)/Delta_time_dlss;
        end;
       end;
      end;


    end;
    //End Mesh Scan in z

    //TDMA coeficients
    For Volume := 0 to MeshSize+1 do begin
     if volume = 0 then begin
      For volume_y := 1 to mesh_wall1 do begin
       if volume_y = 1 then begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Le[Volume,volume_y]*T_wall_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];
       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       Qm_wall[Volume,volume_y] := D_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       end else begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Le[Volume,volume_y]*T_wall_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];

       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       Qm_wall[Volume,volume_y] :=  (D_tdma[Volume,volume_y] - C_tdma[Volume,volume_y]*Qm_wall[Volume,volume_y-1])/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       end;
      end;
     end   //end if volume=0
     else if volume = MeshSize+1 then begin
      For volume_y := 1 to mesh_wall1 do begin
       if volume_y = 1 then begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_wall_1old[Volume-1,volume_y] + B_Lp[Volume,volume_y];
       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       Qm_wall[Volume,volume_y] := D_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       end else begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_wall_1old[Volume-1,volume_y] + B_Lp[Volume,volume_y];

       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       Qm_wall[Volume,volume_y] :=  (D_tdma[Volume,volume_y] - C_tdma[Volume,volume_y]*Qm_wall[Volume,volume_y-1])/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       end;
      end;
     end   //end if volume=MeshSize+1
     else begin
      For volume_y := 0 to mesh_wall1+1 do begin
       if volume_y = 0 then begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_wall_1old[Volume-1,volume_y] + A_Le[Volume,volume_y]*T_wall_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];
       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       Qm_wall[Volume,volume_y] := D_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       end else begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_wall_1old[Volume-1,volume_y] + A_Le[Volume,volume_y]*T_wall_1old[Volume+1,volume_y] + B_Lp[Volume,volume_y];

       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       Qm_wall[Volume,volume_y] :=  (D_tdma[Volume,volume_y] - C_tdma[Volume,volume_y]*Qm_wall[Volume,volume_y-1])/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       end;
      end;
     end;   //end if volume=internos
    end; //en varredura para calcular Pm e Qm do TDMA

    //Solver wall 1
    For Volume := 0 to MeshSize+1 do begin
     if volume = 0 then begin
      For volume_y := mesh_wall1 downto 1 do begin
       if volume_y = mesh_wall1 then begin
        T_wall_1[Volume,volume_y] := Qm_wall[Volume,volume_y];
       end else begin
        T_wall_1[Volume,volume_y] := Pm_wall[Volume,volume_y]*T_wall_1[Volume,volume_y+1] + Qm_wall[Volume,volume_y];
       end;
      end;
     end else if volume = MeshSize+1 then begin
      For volume_y := mesh_wall1 downto 1 do begin
       if volume_y = mesh_wall1 then begin
        T_wall_1[Volume,volume_y] := Qm_wall[Volume,volume_y];
       end else begin
        T_wall_1[Volume,volume_y] := Pm_wall[Volume,volume_y]*T_wall_1[Volume,volume_y+1] + Qm_wall[Volume,volume_y];
       end;
      end;
     end else begin
      For volume_y := mesh_wall1+1 downto 0 do begin
       if volume_y = mesh_wall1+1 then begin
        T_wall_1[Volume,volume_y] := Qm_wall[Volume,volume_y];
       end else begin
        T_wall_1[Volume,volume_y] := Pm_wall[Volume,volume_y]*T_wall_1[Volume,volume_y+1] + Qm_wall[Volume,volume_y];
       end;
      end;
     end;
    end;
    //end solver wall 1




   //Wall 2 Solver
    //Mesh Scan in z direction
    For Volume := 0 to MeshSize+1 do begin

     if (volume > 0) and (volume < MeshSize+1) then begin //if volumes internos onde recebe q_flux e h_conv

      //CC para camada 2 - SUL
      Efvd_f[volume] := Power(k_fp[volume]*cp_fp[volume]*rho_fp[volume],0.5);
      Efvd_s[volume] := Power(k_sp[volume]*cp_sp[volume]*rho_sp[volume],0.5);
      if RG_geometry.ItemIndex = 0 then begin     //Parallel Plates
       if u_D_dlss[Cont_time_cycle,volume] = 0 then begin
        u_wall := 0;
        //T_BC_wall_PM[Volume] := (k_y_wall2*T_wall_2old[Volume,1] + k_fp[volume]*T_fp[volume])/(k_y_wall2 + k_fp[volume]) ;
        T_BC_wall_PM[Volume] := (Efvd_y_wall2*T_1BC[Volume] + (1 - Porosity_p[volume])*Efvd_s[volume]*T_sp[volume] + Porosity_p[volume]*Efvd_f[volume]*T_fp[volume])/
                                (Efvd_y_wall2 + (1 - Porosity_p[volume])*Efvd_s[volume] + Porosity_p[volume]*Efvd_f[volume]);
       end else begin
        h_conv_PM[volume] := 7.541*k_fp[Volume]/Dh_p[volume];
       end;

      end else if RG_geometry.ItemIndex = 1 then begin     //spehres

       if u_D_dlss[Cont_time_cycle,volume] = 0 then begin
        u_wall := 0;
        // T_BC_wall_PM[Volume] := (k_y_wall2*T_wall_2old[Volume,1] + k_fp[volume]*T_fp[volume])/(k_y_wall2 + k_fp[volume]) ;
        T_BC_wall_PM[Volume] := (Efvd_y_wall2*T_1BC[Volume] + (1 - Porosity_p[volume])*Efvd_s[volume]*T_sp[volume] + Porosity_p[volume]*Efvd_f[volume]*T_fp[volume])/
                                (Efvd_y_wall2 + (1 - Porosity_p[volume])*Efvd_s[volume] + Porosity_p[volume]*Efvd_f[volume]);

       end else if u_D_dlss[Cont_time_cycle,volume] > 0 then begin
        if Form_HeatLosses.RG_Nu_HeatWall.ItemIndex = 0 then begin
        h_conv_PM[volume] := 5.78*k_eff_sp[volume]/D_face;     //Bejan
        end else begin
        u_wall := u_CB[Cont_time_cycle,volume];
        Re_wall[volume] := ABS(u_wall)*Dp_p[volume]/nu_fp[Volume]; //Li
        h_conv_PM[volume] := 0.17*Power(Re_wall[volume],0.79)*k_fp[Volume]/Dp_p[volume];
        end;
       end else begin
        //if Form_HeatLosses.RG_Nu_HeatWall.ItemIndex = 0 then begin
        //h_conv_PM[volume] := 5.78*k_eff_sp[volume]/D_face;     //Bejan
        //end else begin
        u_wall := u_HB[Cont_time_cycle,volume];
        Re_wall[volume] := ABS(u_wall)*Dp_p[volume]/nu_fp[Volume]; //Li
        h_conv_PM[volume] := 0.17*Power(Re_wall[volume],0.79)*k_fp[Volume]/Dp_p[volume];
        //end;
       end;

      end else if RG_geometry.ItemIndex = 2 then begin     //pins

       if u_D_dlss[Cont_time_cycle,volume] = 0 then begin
        u_wall := 0;
        //  T_BC_wall_PM[Volume] := (k_y_wall2*T_wall_2old[Volume,1] + k_fp[volume]*T_fp[volume])/(k_y_wall2 + k_fp[volume]) ;
        T_BC_wall_PM[Volume] := (Efvd_y_wall2*T_1BC[Volume] + (1 - Porosity_p[volume])*Efvd_s[volume]*T_sp[volume] + Porosity_p[volume]*Efvd_f[volume]*T_fp[volume])/
                                (Efvd_y_wall2 + (1 - Porosity_p[volume])*Efvd_s[volume] + Porosity_p[volume]*Efvd_f[volume]);

       end else if u_D_dlss[Cont_time_cycle,volume] > 0 then begin
        u_wall := u_CB[Cont_time_cycle,volume];
        Re_wall[volume] := ABS(u_wall)*Dp_p[volume]/nu_fp[Volume]; //Li
        h_conv_PM[volume] := 0.16*Power(Re_wall[volume],0.93)*k_fp[Volume]/Dp_p[volume];
       end else begin
        u_wall := u_HB[Cont_time_cycle,volume];
        Re_wall[volume] := ABS(u_wall)*Dp_p[volume]/nu_fp[Volume]; //Li
        h_conv_PM[volume] := 0.16*Power(Re_wall[volume],0.93)*k_fp[Volume]/Dp_p[volume];
       end;
      end;

     //Condicao de contorno de temperatura - NORTE
     T_2BC[Volume] := ((k_y_wall1/Delta_y1)*T_wall_1old[Volume,1] +
                       (k_y_wall2/Delta_y2)*T_wall_2old[Volume,mesh_wall2])/
                      ((k_y_wall1/Delta_y1) + (k_y_wall2/Delta_y2));


     end; //end if volumes internos onde recebe q_flux e h_conv

     //Matrix coeficients

      if volume = 0 then begin  //CC em West
       For volume_y := 1 to mesh_wall2 do begin
        A_Lw[Volume,volume_y]:=0;
        A_Le[Volume,volume_y]:=1;
        A_Ln[Volume,volume_y]:=0;
        A_Ls[Volume,volume_y]:=0;
        A_Lp[Volume,volume_y]:= 1;
        B_Lp[Volume,volume_y]:= 0;
       end;
      end else if volume = MeshSize+1 then begin //CC em East
       For volume_y := 1 to mesh_wall2 do begin
        A_Lw[Volume,volume_y]:=1;
        A_Le[Volume,volume_y]:=0;
        A_Ln[Volume,volume_y]:=0;
        A_Ls[Volume,volume_y]:=0;
        A_Lp[Volume,volume_y]:= 1;
        B_Lp[Volume,volume_y]:= 0;
       end;
      end else begin //volumes internos em z
       For volume_y := 0 to mesh_wall2+1 do begin
        if volume_y = 0 then begin //CC sul
         A_Lw[Volume,volume_y]:=0;
         A_Le[Volume,volume_y]:=0;
         A_Ln[Volume,volume_y]:= - (h_conv_PM[volume]/2) + (k_y_wall2/Delta_y2);
         A_Ls[Volume,volume_y]:=0;
         A_Lp[Volume,volume_y]:= (h_conv_PM[volume]/2) + (k_y_wall2/Delta_y2);
         B_Lp[Volume,volume_y]:= h_conv_PM[volume]*T_fp[volume];
        end else if volume_y = mesh_wall2+1 then begin //CC Norte
         A_Lw[Volume,volume_y]:=0;
         A_Le[Volume,volume_y]:=0;
         A_Ln[Volume,volume_y]:=0;
         A_Ls[Volume,volume_y]:=-1;
         A_Lp[Volume,volume_y]:= 1;
         B_Lp[Volume,volume_y]:= 2*T_2BC[Volume] ;
        end else begin //volumes internos em y
         A_Lw[Volume,volume_y]:=(dif_z_wall2/(omega*Power(L_casing,2)))*(Delta_y2_dlss/Delta_L_dlss);
         A_Le[Volume,volume_y]:=(dif_z_wall2/(omega*Power(L_casing,2)))*(Delta_y2_dlss/Delta_L_dlss);
         A_Ln[Volume,volume_y]:=(dif_y_wall2/(omega*Power(e_wall2,2)))*(Delta_L_dlss/Delta_y2_dlss);
         A_Ls[Volume,volume_y]:=(dif_y_wall2/(omega*Power(e_wall2,2)))*(Delta_L_dlss/Delta_y2_dlss);
         A_Lp[Volume,volume_y]:= A_Lw[Volume,volume_y] + A_Le[Volume,volume_y] +
                                 A_Ln[Volume,volume_y] + A_Ls[Volume,volume_y] +
                                (Delta_L_dlss*Delta_y2_dlss)/Delta_time_dlss;
         B_Lp[Volume,volume_y]:= T_wall2_TSBefore[Volume,volume_y]*(Delta_L_dlss*Delta_y2_dlss)/Delta_time_dlss;
        end;
       end;
      end;


    end;
    //End Mesh Scan in z

    //TDMA coeficients
    For Volume := 0 to MeshSize+1 do begin
     if volume = 0 then begin
      For volume_y := 1 to mesh_wall2 do begin
       if volume_y = 1 then begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Le[Volume,volume_y]*T_wall_2old[Volume+1,volume_y] + B_Lp[Volume,volume_y];
       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       Qm_wall[Volume,volume_y] := D_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       end else begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Le[Volume,volume_y]*T_wall_2old[Volume+1,volume_y] + B_Lp[Volume,volume_y];

       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       Qm_wall[Volume,volume_y] :=  (D_tdma[Volume,volume_y] - C_tdma[Volume,volume_y]*Qm_wall[Volume,volume_y-1])/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       end;
      end;
     end   //end if volume=0
     else if volume = MeshSize+1 then begin
      For volume_y := 1 to mesh_wall2 do begin
       if volume_y = 1 then begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_wall_2old[Volume-1,volume_y] + B_Lp[Volume,volume_y];
       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       Qm_wall[Volume,volume_y] := D_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       end else begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_wall_2old[Volume-1,volume_y] + B_Lp[Volume,volume_y];

       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       Qm_wall[Volume,volume_y] :=  (D_tdma[Volume,volume_y] - C_tdma[Volume,volume_y]*Qm_wall[Volume,volume_y-1])/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       end;
      end;
     end   //end if volume=MeshSize+1
     else begin
      For volume_y := 0 to mesh_wall2+1 do begin
       if volume_y = 0 then begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_wall_2old[Volume-1,volume_y] + A_Le[Volume,volume_y]*T_wall_2old[Volume+1,volume_y] + B_Lp[Volume,volume_y];
       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       Qm_wall[Volume,volume_y] := D_tdma[Volume,volume_y]/A_tdma[Volume,volume_y];
       end else begin
       A_tdma[Volume,volume_y] := A_Lp[Volume,volume_y];
       B_tdma[Volume,volume_y] := - A_Ln[Volume,volume_y];
       C_tdma[Volume,volume_y] := -A_Ls[Volume,volume_y];
       D_tdma[Volume,volume_y] := A_Lw[Volume,volume_y]*T_wall_2old[Volume-1,volume_y] + A_Le[Volume,volume_y]*T_wall_2old[Volume+1,volume_y] + B_Lp[Volume,volume_y];

       Pm_wall[Volume,volume_y] := - B_tdma[Volume,volume_y]/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       Qm_wall[Volume,volume_y] :=  (D_tdma[Volume,volume_y] - C_tdma[Volume,volume_y]*Qm_wall[Volume,volume_y-1])/
                                    (A_tdma[Volume,volume_y] + C_tdma[Volume,volume_y]*Pm_wall[Volume,volume_y-1]);
       end;
      end;
     end;   //end if volume=internos
    end; //en varredura para calcular Pm e Qm do TDMA

    //Solver wall 2
    For Volume := 0 to MeshSize+1 do begin
     if volume = 0 then begin
      For volume_y := mesh_wall2 downto 1 do begin
       if volume_y = mesh_wall2 then begin
        T_wall_2[Volume,volume_y] := Qm_wall[Volume,volume_y];
       end else begin
        T_wall_2[Volume,volume_y] := Pm_wall[Volume,volume_y]*T_wall_2[Volume,volume_y+1] + Qm_wall[Volume,volume_y];
       end;
      end;
     end else if volume = MeshSize+1 then begin
      For volume_y := mesh_wall2 downto 1 do begin
       if volume_y = mesh_wall2 then begin
        T_wall_2[Volume,volume_y] := Qm_wall[Volume,volume_y];
       end else begin
        T_wall_2[Volume,volume_y] := Pm_wall[Volume,volume_y]*T_wall_2[Volume,volume_y+1] + Qm_wall[Volume,volume_y];
       end;
      end;
     end else begin
      For volume_y := mesh_wall2+1 downto 0 do begin
       if volume_y = mesh_wall2+1 then begin
        T_wall_2[Volume,volume_y] := Qm_wall[Volume,volume_y];
       end else begin
        T_wall_2[Volume,volume_y] := Pm_wall[Volume,volume_y]*T_wall_2[Volume,volume_y+1] + Qm_wall[Volume,volume_y];
       end;
      end;
     end;
    end;
    //end solver wall 2




    //Erro wall 1
    SUM_wall1 := 0;
    For Volume := 1 to MeshSize do begin
     For volume_y :=1 to mesh_wall2 do begin
      SUM_wall1 := SUM_wall1 + Power((T_wall_1[Volume,volume_y] - T_wall_1old[Volume,volume_y]),2);
     end;
    end;

    Erro_Twall_1 := Power(SUM_wall1, 0.5);


    //Erro wall 2
    SUM_wall2 := 0;
    For Volume := 1 to MeshSize do begin
     For volume_y :=1 to mesh_wall2 do begin
      SUM_wall2 := SUM_wall2 + Power((T_wall_2[Volume,volume_y] - T_wall_2old[Volume,volume_y]),2);
     end;
    end;

    Erro_Twall_2 := Power(SUM_wall2, 0.5);

    //Erro Air 1
    SUM_air1 := 0;
    For Volume := 1 to MeshSize do begin
     For volume_y :=1 to mesh_air1 do begin
      SUM_air1 := SUM_air1 + Power((T_air_1[Volume,volume_y] - T_air_1old[Volume,volume_y]),2);
     end;
    end;

    Erro_Tair_1 := Power(SUM_air1, 0.5);

    if Cont_Loss_ini < 50 then begin
      if (Erro_Twall_1 < Power(10,-6)) and (Erro_Twall_2 < Power(10,-6)) and (Erro_Tair_1 < Power(10,-6)) then begin
      Error_Loss := 1;
      end;
    end else begin
     Error_Loss := 1;
    end;

   end; //end if para 2 camadas


  Cont_Loss := Cont_Loss+1;
  end; //End criterio de convergencia




  //calculo do calor pela parede
  //Para 1 camada
  if Form_HeatLosses.RG_NoWalls.ItemIndex = 0 then begin
   For Volume := 0 to MeshSize+1 do begin
     For volume_y := 0 to mesh_wall1+1 do begin
     Theta_wall1[volume,volume_y] := T_wall_1[Volume,volume_y];
     end;

     For volume_y := 0 to mesh_air1+1 do begin
     Theta_air1[volume,volume_y] := T_air_1[Volume,volume_y];
     end;

     //y-averaged temperature of the casing
      if (RG_entropy.ItemIndex = 2) then begin
       Sum_yavg := 0;
       For volume_y := 1 to mesh_wall1 do begin
       Sum_yavg := Sum_yavg+T_wall_1[Volume,volume_y];
       end;
      T_wall1_yavg[Cont_time_cycle,volume] := (Sum_yavg/mesh_wall1);
      end;
      //end y-averaged temperature of the casing


    if (volume = 0) or (volume = MeshSize+1) then begin
    Theta_borderMP[volume]:= 0;
    Q_WallLoss[Cont_time_cycle,volume] := 0;
    end else begin
    Theta_borderMP[volume]:= ((T_wall_1[Volume,1]+T_wall_1[Volume,0])/2);
    Q_WallLoss[Cont_time_cycle,volume] := -h_conv_PM[volume]*(Perimeter/A_face)*((T_fp[volume] - Theta_borderMP[volume])*T_spam);
    Temp_border[Cont_time_cycle,volume] :=  Theta_borderMP[volume];
    end;
   end;
  end;

  //Para 2 camadas
  if Form_HeatLosses.RG_NoWalls.ItemIndex = 1 then begin
   For Volume := 0 to MeshSize+1 do begin
     For volume_y := 0 to mesh_wall1+1 do begin
     Theta_wall1[volume,volume_y] := T_wall_1[Volume,volume_y];
     end;

     For volume_y := 0 to mesh_wall2+1 do begin
     Theta_wall2[volume,volume_y] := T_wall_2[Volume,volume_y];
     end;

     For volume_y := 0 to mesh_air1+1 do begin
     Theta_air1[volume,volume_y] := T_air_1[Volume,volume_y];
     end;

     //y-averaged temperature of the casing
      if (RG_entropy.ItemIndex = 2) then begin
       Sum_yavg := 0;
       For volume_y := 1 to mesh_wall1 do begin
       Sum_yavg := Sum_yavg+T_wall_1[Volume,volume_y];
       end;
      T_wall1_yavg[Cont_time_cycle,volume] := (Sum_yavg/mesh_wall1);

       Sum_yavg := 0;
       For volume_y := 1 to mesh_wall2 do begin
       Sum_yavg := Sum_yavg+T_wall_2[Volume,volume_y];
       end;
      T_wall2_yavg[Cont_time_cycle,volume] := (Sum_yavg/mesh_wall2);
      end;
      //end y-averaged temperature of the casing


    if (volume = 0) or (volume = MeshSize+1) then begin
    Theta_borderMP[volume]:= 0;
    Q_WallLoss[Cont_time_cycle,volume] := 0;
    end else begin
    Theta_borderMP[volume]:= ((T_wall_2[Volume,1]+T_wall_2[Volume,0])/2);
    Q_WallLoss[Cont_time_cycle,volume] := -h_conv_PM[volume]*(Perimeter/A_face)*((T_fp[volume] - Theta_borderMP[volume])*T_spam);
    Temp_border[Cont_time_cycle,volume] :=  Theta_borderMP[volume];
    end;
   end;
  end;


//Temperatures at cycle instants
if Cont_time_cycle = HalfTimeStep then begin //apos CB
 //1 camada
 if Form_HeatLosses.RG_NoWalls.ItemIndex = 0 then begin
  For Volume := 0 to MeshSize+1 do begin
   For volume_y := 0 to mesh_wall1+1 do begin
    if volume_y = 0 then begin
     Wall1_CB[volume,volume_y] := (Theta_wall1[volume,0]+Theta_wall1[volume,1])/2;
    end else if volume_y = mesh_wall1+1 then begin
     Wall1_CB[volume,volume_y] := (Theta_wall1[volume,mesh_wall1]+Theta_wall1[volume,mesh_wall1+1])/2;
    end else begin
     Wall1_CB[volume,volume_y] := Theta_wall1[volume,volume_y];
    end;
   end;

   For volume_y := 0 to mesh_air1+1 do begin
    if volume_y = 0 then begin
     Air1_CB[volume,volume_y] := (Theta_air1[volume,0]+Theta_air1[volume,1])/2;
    end else if volume_y = mesh_air1+1 then begin
     Air1_CB[volume,volume_y] := (Theta_air1[volume,mesh_air1]+Theta_air1[volume,mesh_air1+1])/2;
    end else begin
     Air1_CB[volume,volume_y] := Theta_air1[volume,volume_y];
    end;
   end;

  end;
 end;


 //Para 2 camadas
 if Form_HeatLosses.RG_NoWalls.ItemIndex = 1 then begin
  For Volume := 0 to MeshSize+1 do begin
   For volume_y := 0 to mesh_wall1+1 do begin
    if volume_y = 0 then begin
     Wall1_CB[volume,volume_y] := (Theta_wall1[volume,0]+Theta_wall1[volume,1])/2;
    end else if volume_y = mesh_wall1+1 then begin
     Wall1_CB[volume,volume_y] := (Theta_wall1[volume,mesh_wall1]+Theta_wall1[volume,mesh_wall1+1])/2;
    end else begin
     Wall1_CB[volume,volume_y] := Theta_wall1[volume,volume_y];
    end;
   end;

   For volume_y := 0 to mesh_wall2+1 do begin
    if volume_y = 0 then begin
     Wall2_CB[volume,volume_y] := (Theta_wall2[volume,0]+Theta_wall2[volume,1])/2;
    end else if volume_y = mesh_wall2+1 then begin
     Wall2_CB[volume,volume_y] := (Theta_wall2[volume,mesh_wall2]+Theta_wall2[volume,mesh_wall2+1])/2;
    end else begin
     Wall2_CB[volume,volume_y] := Theta_wall2[volume,volume_y];
    end;
   end;

   For volume_y := 0 to mesh_air1+1 do begin
    if volume_y = 0 then begin
     Air1_CB[volume,volume_y] := (Theta_air1[volume,0]+Theta_air1[volume,1])/2;
    end else if volume_y = mesh_air1+1 then begin
     Air1_CB[volume,volume_y] := (Theta_air1[volume,mesh_air1]+Theta_air1[volume,mesh_air1+1])/2;
    end else begin
     Air1_CB[volume,volume_y] := Theta_air1[volume,volume_y];
    end;
   end;

  end;
 end;

end else if Cont_time_cycle = TimeStep then begin //apos HB

 //1 camada
 if Form_HeatLosses.RG_NoWalls.ItemIndex = 0 then begin
  For Volume := 0 to MeshSize+1 do begin
   For volume_y := 0 to mesh_wall1+1 do begin
    if volume_y = 0 then begin
     Wall1_HB[volume,volume_y] := (Theta_wall1[volume,0]+Theta_wall1[volume,1])/2;
    end else if volume_y = mesh_wall1+1 then begin
     Wall1_HB[volume,volume_y] := (Theta_wall1[volume,mesh_wall1]+Theta_wall1[volume,mesh_wall1+1])/2;
    end else begin
     Wall1_HB[volume,volume_y] := Theta_wall1[volume,volume_y];
    end;
   end;

   For volume_y := 0 to mesh_air1+1 do begin
    if volume_y = 0 then begin
     Air1_HB[volume,volume_y] := (Theta_air1[volume,0]+Theta_air1[volume,1])/2;
    end else if volume_y = mesh_air1+1 then begin
     Air1_HB[volume,volume_y] := (Theta_air1[volume,mesh_air1]+Theta_air1[volume,mesh_air1+1])/2;
    end else begin
     Air1_HB[volume,volume_y] := Theta_air1[volume,volume_y];
    end;
   end;

  end;
 end;

 //Para 2 camadas
 if Form_HeatLosses.RG_NoWalls.ItemIndex = 1 then begin
  For Volume := 0 to MeshSize+1 do begin
   For volume_y := 0 to mesh_wall1+1 do begin
    if volume_y = 0 then begin
     Wall1_HB[volume,volume_y] := (Theta_wall1[volume,0]+Theta_wall1[volume,1])/2;
    end else if volume_y = mesh_wall1+1 then begin
     Wall1_HB[volume,volume_y] := (Theta_wall1[volume,mesh_wall1]+Theta_wall1[volume,mesh_wall1+1])/2;
    end else begin
     Wall1_HB[volume,volume_y] := Theta_wall1[volume,volume_y];
    end;
   end;

   For volume_y := 0 to mesh_wall2+1 do begin
    if volume_y = 0 then begin
     Wall2_HB[volume,volume_y] := (Theta_wall2[volume,0]+Theta_wall2[volume,1])/2;
    end else if volume_y = mesh_wall2+1 then begin
     Wall2_HB[volume,volume_y] := (Theta_wall2[volume,mesh_wall2]+Theta_wall2[volume,mesh_wall2+1])/2;
    end else begin
     Wall2_HB[volume,volume_y] := Theta_wall2[volume,volume_y];
    end;
   end;

   For volume_y := 0 to mesh_air1+1 do begin
    if volume_y = 0 then begin
     Air1_HB[volume,volume_y] := (Theta_air1[volume,0]+Theta_air1[volume,1])/2;
    end else if volume_y = mesh_air1+1 then begin
     Air1_HB[volume,volume_y] := (Theta_air1[volume,mesh_air1]+Theta_air1[volume,mesh_air1+1])/2;
    end else begin
     Air1_HB[volume,volume_y] := Theta_air1[volume,volume_y];
    end;
   end;

  end;
 end;
end;
  //End Temperatures at cycle instants

